/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.io = (function() {

    /**
     * Namespace io.
     * @exports io
     * @namespace
     */
    var io = {};

    io.cucumber = (function() {

        /**
         * Namespace cucumber.
         * @memberof io
         * @namespace
         */
        var cucumber = {};

        cucumber.messages = (function() {

            /**
             * Namespace messages.
             * @memberof io.cucumber
             * @namespace
             */
            var messages = {};

            messages.Envelope = (function() {

                /**
                 * Properties of an Envelope.
                 * @memberof io.cucumber.messages
                 * @interface IEnvelope
                 * @property {io.cucumber.messages.ISource|null} [source] Envelope source
                 * @property {io.cucumber.messages.IGherkinDocument|null} [gherkinDocument] Envelope gherkinDocument
                 * @property {io.cucumber.messages.IPickle|null} [pickle] Envelope pickle
                 * @property {io.cucumber.messages.IStepDefinition|null} [stepDefinition] Envelope stepDefinition
                 * @property {io.cucumber.messages.IHook|null} [hook] Envelope hook
                 * @property {io.cucumber.messages.IParameterType|null} [parameterType] Envelope parameterType
                 * @property {io.cucumber.messages.ITestCase|null} [testCase] Envelope testCase
                 * @property {io.cucumber.messages.IUndefinedParameterType|null} [undefinedParameterType] Envelope undefinedParameterType
                 * @property {io.cucumber.messages.ITestRunStarted|null} [testRunStarted] Envelope testRunStarted
                 * @property {io.cucumber.messages.ITestCaseStarted|null} [testCaseStarted] Envelope testCaseStarted
                 * @property {io.cucumber.messages.ITestStepStarted|null} [testStepStarted] Envelope testStepStarted
                 * @property {io.cucumber.messages.IAttachment|null} [attachment] Envelope attachment
                 * @property {io.cucumber.messages.ITestStepFinished|null} [testStepFinished] Envelope testStepFinished
                 * @property {io.cucumber.messages.ITestCaseFinished|null} [testCaseFinished] Envelope testCaseFinished
                 * @property {io.cucumber.messages.ITestRunFinished|null} [testRunFinished] Envelope testRunFinished
                 * @property {io.cucumber.messages.IParseError|null} [parseError] Envelope parseError
                 * @property {io.cucumber.messages.IMeta|null} [meta] Envelope meta
                 */

                /**
                 * Constructs a new Envelope.
                 * @memberof io.cucumber.messages
                 * @classdesc All the messages that are passed between different components/processes are Envelope
                 * messages.
                 * @implements IEnvelope
                 * @constructor
                 * @param {io.cucumber.messages.IEnvelope=} [properties] Properties to set
                 */
                function Envelope(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Envelope source.
                 * @member {io.cucumber.messages.ISource|null|undefined} source
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.source = null;

                /**
                 * Envelope gherkinDocument.
                 * @member {io.cucumber.messages.IGherkinDocument|null|undefined} gherkinDocument
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.gherkinDocument = null;

                /**
                 * Envelope pickle.
                 * @member {io.cucumber.messages.IPickle|null|undefined} pickle
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.pickle = null;

                /**
                 * Envelope stepDefinition.
                 * @member {io.cucumber.messages.IStepDefinition|null|undefined} stepDefinition
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.stepDefinition = null;

                /**
                 * Envelope hook.
                 * @member {io.cucumber.messages.IHook|null|undefined} hook
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.hook = null;

                /**
                 * Envelope parameterType.
                 * @member {io.cucumber.messages.IParameterType|null|undefined} parameterType
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.parameterType = null;

                /**
                 * Envelope testCase.
                 * @member {io.cucumber.messages.ITestCase|null|undefined} testCase
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testCase = null;

                /**
                 * Envelope undefinedParameterType.
                 * @member {io.cucumber.messages.IUndefinedParameterType|null|undefined} undefinedParameterType
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.undefinedParameterType = null;

                /**
                 * Envelope testRunStarted.
                 * @member {io.cucumber.messages.ITestRunStarted|null|undefined} testRunStarted
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testRunStarted = null;

                /**
                 * Envelope testCaseStarted.
                 * @member {io.cucumber.messages.ITestCaseStarted|null|undefined} testCaseStarted
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testCaseStarted = null;

                /**
                 * Envelope testStepStarted.
                 * @member {io.cucumber.messages.ITestStepStarted|null|undefined} testStepStarted
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testStepStarted = null;

                /**
                 * Envelope attachment.
                 * @member {io.cucumber.messages.IAttachment|null|undefined} attachment
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.attachment = null;

                /**
                 * Envelope testStepFinished.
                 * @member {io.cucumber.messages.ITestStepFinished|null|undefined} testStepFinished
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testStepFinished = null;

                /**
                 * Envelope testCaseFinished.
                 * @member {io.cucumber.messages.ITestCaseFinished|null|undefined} testCaseFinished
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testCaseFinished = null;

                /**
                 * Envelope testRunFinished.
                 * @member {io.cucumber.messages.ITestRunFinished|null|undefined} testRunFinished
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.testRunFinished = null;

                /**
                 * Envelope parseError.
                 * @member {io.cucumber.messages.IParseError|null|undefined} parseError
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.parseError = null;

                /**
                 * Envelope meta.
                 * @member {io.cucumber.messages.IMeta|null|undefined} meta
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Envelope.prototype.meta = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Envelope message.
                 * @member {"source"|"gherkinDocument"|"pickle"|"stepDefinition"|"hook"|"parameterType"|"testCase"|"undefinedParameterType"|"testRunStarted"|"testCaseStarted"|"testStepStarted"|"attachment"|"testStepFinished"|"testCaseFinished"|"testRunFinished"|"parseError"|"meta"|undefined} message
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 */
                Object.defineProperty(Envelope.prototype, "message", {
                    get: $util.oneOfGetter($oneOfFields = ["source", "gherkinDocument", "pickle", "stepDefinition", "hook", "parameterType", "testCase", "undefinedParameterType", "testRunStarted", "testCaseStarted", "testStepStarted", "attachment", "testStepFinished", "testCaseFinished", "testRunFinished", "parseError", "meta"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Envelope instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {io.cucumber.messages.IEnvelope=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Envelope} Envelope instance
                 */
                Envelope.create = function create(properties) {
                    return new Envelope(properties);
                };

                /**
                 * Encodes the specified Envelope message. Does not implicitly {@link io.cucumber.messages.Envelope.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {io.cucumber.messages.IEnvelope} message Envelope message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Envelope.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                        $root.io.cucumber.messages.Source.encode(message.source, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.gherkinDocument != null && Object.hasOwnProperty.call(message, "gherkinDocument"))
                        $root.io.cucumber.messages.GherkinDocument.encode(message.gherkinDocument, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.pickle != null && Object.hasOwnProperty.call(message, "pickle"))
                        $root.io.cucumber.messages.Pickle.encode(message.pickle, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.stepDefinition != null && Object.hasOwnProperty.call(message, "stepDefinition"))
                        $root.io.cucumber.messages.StepDefinition.encode(message.stepDefinition, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.hook != null && Object.hasOwnProperty.call(message, "hook"))
                        $root.io.cucumber.messages.Hook.encode(message.hook, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.parameterType != null && Object.hasOwnProperty.call(message, "parameterType"))
                        $root.io.cucumber.messages.ParameterType.encode(message.parameterType, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.testCase != null && Object.hasOwnProperty.call(message, "testCase"))
                        $root.io.cucumber.messages.TestCase.encode(message.testCase, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.undefinedParameterType != null && Object.hasOwnProperty.call(message, "undefinedParameterType"))
                        $root.io.cucumber.messages.UndefinedParameterType.encode(message.undefinedParameterType, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.testRunStarted != null && Object.hasOwnProperty.call(message, "testRunStarted"))
                        $root.io.cucumber.messages.TestRunStarted.encode(message.testRunStarted, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.testCaseStarted != null && Object.hasOwnProperty.call(message, "testCaseStarted"))
                        $root.io.cucumber.messages.TestCaseStarted.encode(message.testCaseStarted, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.testStepStarted != null && Object.hasOwnProperty.call(message, "testStepStarted"))
                        $root.io.cucumber.messages.TestStepStarted.encode(message.testStepStarted, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.attachment != null && Object.hasOwnProperty.call(message, "attachment"))
                        $root.io.cucumber.messages.Attachment.encode(message.attachment, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.testStepFinished != null && Object.hasOwnProperty.call(message, "testStepFinished"))
                        $root.io.cucumber.messages.TestStepFinished.encode(message.testStepFinished, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.testCaseFinished != null && Object.hasOwnProperty.call(message, "testCaseFinished"))
                        $root.io.cucumber.messages.TestCaseFinished.encode(message.testCaseFinished, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.testRunFinished != null && Object.hasOwnProperty.call(message, "testRunFinished"))
                        $root.io.cucumber.messages.TestRunFinished.encode(message.testRunFinished, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.parseError != null && Object.hasOwnProperty.call(message, "parseError"))
                        $root.io.cucumber.messages.ParseError.encode(message.parseError, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                        $root.io.cucumber.messages.Meta.encode(message.meta, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Envelope message, length delimited. Does not implicitly {@link io.cucumber.messages.Envelope.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {io.cucumber.messages.IEnvelope} message Envelope message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Envelope.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Envelope message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Envelope} Envelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Envelope.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Envelope();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.source = $root.io.cucumber.messages.Source.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.gherkinDocument = $root.io.cucumber.messages.GherkinDocument.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.pickle = $root.io.cucumber.messages.Pickle.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.stepDefinition = $root.io.cucumber.messages.StepDefinition.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.hook = $root.io.cucumber.messages.Hook.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.parameterType = $root.io.cucumber.messages.ParameterType.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.testCase = $root.io.cucumber.messages.TestCase.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.undefinedParameterType = $root.io.cucumber.messages.UndefinedParameterType.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.testRunStarted = $root.io.cucumber.messages.TestRunStarted.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.testCaseStarted = $root.io.cucumber.messages.TestCaseStarted.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.testStepStarted = $root.io.cucumber.messages.TestStepStarted.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.attachment = $root.io.cucumber.messages.Attachment.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.testStepFinished = $root.io.cucumber.messages.TestStepFinished.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.testCaseFinished = $root.io.cucumber.messages.TestCaseFinished.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.testRunFinished = $root.io.cucumber.messages.TestRunFinished.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.parseError = $root.io.cucumber.messages.ParseError.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.meta = $root.io.cucumber.messages.Meta.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Envelope message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Envelope} Envelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Envelope.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Envelope message.
                 * @function verify
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Envelope.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.source != null && message.hasOwnProperty("source")) {
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Source.verify(message.source);
                            if (error)
                                return "source." + error;
                        }
                    }
                    if (message.gherkinDocument != null && message.hasOwnProperty("gherkinDocument")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.GherkinDocument.verify(message.gherkinDocument);
                            if (error)
                                return "gherkinDocument." + error;
                        }
                    }
                    if (message.pickle != null && message.hasOwnProperty("pickle")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Pickle.verify(message.pickle);
                            if (error)
                                return "pickle." + error;
                        }
                    }
                    if (message.stepDefinition != null && message.hasOwnProperty("stepDefinition")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.StepDefinition.verify(message.stepDefinition);
                            if (error)
                                return "stepDefinition." + error;
                        }
                    }
                    if (message.hook != null && message.hasOwnProperty("hook")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Hook.verify(message.hook);
                            if (error)
                                return "hook." + error;
                        }
                    }
                    if (message.parameterType != null && message.hasOwnProperty("parameterType")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.ParameterType.verify(message.parameterType);
                            if (error)
                                return "parameterType." + error;
                        }
                    }
                    if (message.testCase != null && message.hasOwnProperty("testCase")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestCase.verify(message.testCase);
                            if (error)
                                return "testCase." + error;
                        }
                    }
                    if (message.undefinedParameterType != null && message.hasOwnProperty("undefinedParameterType")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.UndefinedParameterType.verify(message.undefinedParameterType);
                            if (error)
                                return "undefinedParameterType." + error;
                        }
                    }
                    if (message.testRunStarted != null && message.hasOwnProperty("testRunStarted")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestRunStarted.verify(message.testRunStarted);
                            if (error)
                                return "testRunStarted." + error;
                        }
                    }
                    if (message.testCaseStarted != null && message.hasOwnProperty("testCaseStarted")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestCaseStarted.verify(message.testCaseStarted);
                            if (error)
                                return "testCaseStarted." + error;
                        }
                    }
                    if (message.testStepStarted != null && message.hasOwnProperty("testStepStarted")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestStepStarted.verify(message.testStepStarted);
                            if (error)
                                return "testStepStarted." + error;
                        }
                    }
                    if (message.attachment != null && message.hasOwnProperty("attachment")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Attachment.verify(message.attachment);
                            if (error)
                                return "attachment." + error;
                        }
                    }
                    if (message.testStepFinished != null && message.hasOwnProperty("testStepFinished")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestStepFinished.verify(message.testStepFinished);
                            if (error)
                                return "testStepFinished." + error;
                        }
                    }
                    if (message.testCaseFinished != null && message.hasOwnProperty("testCaseFinished")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestCaseFinished.verify(message.testCaseFinished);
                            if (error)
                                return "testCaseFinished." + error;
                        }
                    }
                    if (message.testRunFinished != null && message.hasOwnProperty("testRunFinished")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.TestRunFinished.verify(message.testRunFinished);
                            if (error)
                                return "testRunFinished." + error;
                        }
                    }
                    if (message.parseError != null && message.hasOwnProperty("parseError")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.ParseError.verify(message.parseError);
                            if (error)
                                return "parseError." + error;
                        }
                    }
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.Meta.verify(message.meta);
                            if (error)
                                return "meta." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Envelope} Envelope
                 */
                Envelope.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Envelope)
                        return object;
                    var message = new $root.io.cucumber.messages.Envelope();
                    if (object.source != null) {
                        if (typeof object.source !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.source: object expected");
                        message.source = $root.io.cucumber.messages.Source.fromObject(object.source);
                    }
                    if (object.gherkinDocument != null) {
                        if (typeof object.gherkinDocument !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.gherkinDocument: object expected");
                        message.gherkinDocument = $root.io.cucumber.messages.GherkinDocument.fromObject(object.gherkinDocument);
                    }
                    if (object.pickle != null) {
                        if (typeof object.pickle !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.pickle: object expected");
                        message.pickle = $root.io.cucumber.messages.Pickle.fromObject(object.pickle);
                    }
                    if (object.stepDefinition != null) {
                        if (typeof object.stepDefinition !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.stepDefinition: object expected");
                        message.stepDefinition = $root.io.cucumber.messages.StepDefinition.fromObject(object.stepDefinition);
                    }
                    if (object.hook != null) {
                        if (typeof object.hook !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.hook: object expected");
                        message.hook = $root.io.cucumber.messages.Hook.fromObject(object.hook);
                    }
                    if (object.parameterType != null) {
                        if (typeof object.parameterType !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.parameterType: object expected");
                        message.parameterType = $root.io.cucumber.messages.ParameterType.fromObject(object.parameterType);
                    }
                    if (object.testCase != null) {
                        if (typeof object.testCase !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testCase: object expected");
                        message.testCase = $root.io.cucumber.messages.TestCase.fromObject(object.testCase);
                    }
                    if (object.undefinedParameterType != null) {
                        if (typeof object.undefinedParameterType !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.undefinedParameterType: object expected");
                        message.undefinedParameterType = $root.io.cucumber.messages.UndefinedParameterType.fromObject(object.undefinedParameterType);
                    }
                    if (object.testRunStarted != null) {
                        if (typeof object.testRunStarted !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testRunStarted: object expected");
                        message.testRunStarted = $root.io.cucumber.messages.TestRunStarted.fromObject(object.testRunStarted);
                    }
                    if (object.testCaseStarted != null) {
                        if (typeof object.testCaseStarted !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testCaseStarted: object expected");
                        message.testCaseStarted = $root.io.cucumber.messages.TestCaseStarted.fromObject(object.testCaseStarted);
                    }
                    if (object.testStepStarted != null) {
                        if (typeof object.testStepStarted !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testStepStarted: object expected");
                        message.testStepStarted = $root.io.cucumber.messages.TestStepStarted.fromObject(object.testStepStarted);
                    }
                    if (object.attachment != null) {
                        if (typeof object.attachment !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.attachment: object expected");
                        message.attachment = $root.io.cucumber.messages.Attachment.fromObject(object.attachment);
                    }
                    if (object.testStepFinished != null) {
                        if (typeof object.testStepFinished !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testStepFinished: object expected");
                        message.testStepFinished = $root.io.cucumber.messages.TestStepFinished.fromObject(object.testStepFinished);
                    }
                    if (object.testCaseFinished != null) {
                        if (typeof object.testCaseFinished !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testCaseFinished: object expected");
                        message.testCaseFinished = $root.io.cucumber.messages.TestCaseFinished.fromObject(object.testCaseFinished);
                    }
                    if (object.testRunFinished != null) {
                        if (typeof object.testRunFinished !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.testRunFinished: object expected");
                        message.testRunFinished = $root.io.cucumber.messages.TestRunFinished.fromObject(object.testRunFinished);
                    }
                    if (object.parseError != null) {
                        if (typeof object.parseError !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.parseError: object expected");
                        message.parseError = $root.io.cucumber.messages.ParseError.fromObject(object.parseError);
                    }
                    if (object.meta != null) {
                        if (typeof object.meta !== "object")
                            throw TypeError(".io.cucumber.messages.Envelope.meta: object expected");
                        message.meta = $root.io.cucumber.messages.Meta.fromObject(object.meta);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Envelope message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Envelope
                 * @static
                 * @param {io.cucumber.messages.Envelope} message Envelope
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Envelope.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.source != null && message.hasOwnProperty("source")) {
                        object.source = $root.io.cucumber.messages.Source.toObject(message.source, options);
                        if (options.oneofs)
                            object.message = "source";
                    }
                    if (message.gherkinDocument != null && message.hasOwnProperty("gherkinDocument")) {
                        object.gherkinDocument = $root.io.cucumber.messages.GherkinDocument.toObject(message.gherkinDocument, options);
                        if (options.oneofs)
                            object.message = "gherkinDocument";
                    }
                    if (message.pickle != null && message.hasOwnProperty("pickle")) {
                        object.pickle = $root.io.cucumber.messages.Pickle.toObject(message.pickle, options);
                        if (options.oneofs)
                            object.message = "pickle";
                    }
                    if (message.stepDefinition != null && message.hasOwnProperty("stepDefinition")) {
                        object.stepDefinition = $root.io.cucumber.messages.StepDefinition.toObject(message.stepDefinition, options);
                        if (options.oneofs)
                            object.message = "stepDefinition";
                    }
                    if (message.hook != null && message.hasOwnProperty("hook")) {
                        object.hook = $root.io.cucumber.messages.Hook.toObject(message.hook, options);
                        if (options.oneofs)
                            object.message = "hook";
                    }
                    if (message.parameterType != null && message.hasOwnProperty("parameterType")) {
                        object.parameterType = $root.io.cucumber.messages.ParameterType.toObject(message.parameterType, options);
                        if (options.oneofs)
                            object.message = "parameterType";
                    }
                    if (message.testCase != null && message.hasOwnProperty("testCase")) {
                        object.testCase = $root.io.cucumber.messages.TestCase.toObject(message.testCase, options);
                        if (options.oneofs)
                            object.message = "testCase";
                    }
                    if (message.undefinedParameterType != null && message.hasOwnProperty("undefinedParameterType")) {
                        object.undefinedParameterType = $root.io.cucumber.messages.UndefinedParameterType.toObject(message.undefinedParameterType, options);
                        if (options.oneofs)
                            object.message = "undefinedParameterType";
                    }
                    if (message.testRunStarted != null && message.hasOwnProperty("testRunStarted")) {
                        object.testRunStarted = $root.io.cucumber.messages.TestRunStarted.toObject(message.testRunStarted, options);
                        if (options.oneofs)
                            object.message = "testRunStarted";
                    }
                    if (message.testCaseStarted != null && message.hasOwnProperty("testCaseStarted")) {
                        object.testCaseStarted = $root.io.cucumber.messages.TestCaseStarted.toObject(message.testCaseStarted, options);
                        if (options.oneofs)
                            object.message = "testCaseStarted";
                    }
                    if (message.testStepStarted != null && message.hasOwnProperty("testStepStarted")) {
                        object.testStepStarted = $root.io.cucumber.messages.TestStepStarted.toObject(message.testStepStarted, options);
                        if (options.oneofs)
                            object.message = "testStepStarted";
                    }
                    if (message.attachment != null && message.hasOwnProperty("attachment")) {
                        object.attachment = $root.io.cucumber.messages.Attachment.toObject(message.attachment, options);
                        if (options.oneofs)
                            object.message = "attachment";
                    }
                    if (message.testStepFinished != null && message.hasOwnProperty("testStepFinished")) {
                        object.testStepFinished = $root.io.cucumber.messages.TestStepFinished.toObject(message.testStepFinished, options);
                        if (options.oneofs)
                            object.message = "testStepFinished";
                    }
                    if (message.testCaseFinished != null && message.hasOwnProperty("testCaseFinished")) {
                        object.testCaseFinished = $root.io.cucumber.messages.TestCaseFinished.toObject(message.testCaseFinished, options);
                        if (options.oneofs)
                            object.message = "testCaseFinished";
                    }
                    if (message.testRunFinished != null && message.hasOwnProperty("testRunFinished")) {
                        object.testRunFinished = $root.io.cucumber.messages.TestRunFinished.toObject(message.testRunFinished, options);
                        if (options.oneofs)
                            object.message = "testRunFinished";
                    }
                    if (message.parseError != null && message.hasOwnProperty("parseError")) {
                        object.parseError = $root.io.cucumber.messages.ParseError.toObject(message.parseError, options);
                        if (options.oneofs)
                            object.message = "parseError";
                    }
                    if (message.meta != null && message.hasOwnProperty("meta")) {
                        object.meta = $root.io.cucumber.messages.Meta.toObject(message.meta, options);
                        if (options.oneofs)
                            object.message = "meta";
                    }
                    return object;
                };

                /**
                 * Converts this Envelope to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Envelope
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Envelope.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Envelope;
            })();

            messages.Meta = (function() {

                /**
                 * Properties of a Meta.
                 * @memberof io.cucumber.messages
                 * @interface IMeta
                 * @property {string|null} [protocolVersion] The [SEMVER](https://semver.org/) version number of the protocol
                 * @property {io.cucumber.messages.Meta.IProduct|null} [implementation] Meta implementation
                 * @property {io.cucumber.messages.Meta.IProduct|null} [runtime] Meta runtime
                 * @property {io.cucumber.messages.Meta.IProduct|null} [os] Meta os
                 * @property {io.cucumber.messages.Meta.IProduct|null} [cpu] Meta cpu
                 * @property {io.cucumber.messages.Meta.ICI|null} [ci] Meta ci
                 */

                /**
                 * Constructs a new Meta.
                 * @memberof io.cucumber.messages
                 * @classdesc This message contains meta information about the environment. Consumers can use
                 * this for various purposes.
                 * @implements IMeta
                 * @constructor
                 * @param {io.cucumber.messages.IMeta=} [properties] Properties to set
                 */
                function Meta(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The [SEMVER](https://semver.org/) version number of the protocol
                 * @member {string} protocolVersion
                 * @memberof io.cucumber.messages.Meta
                 * @instance
                 */
                Meta.prototype.protocolVersion = "";

                /**
                 * Meta implementation.
                 * @member {io.cucumber.messages.Meta.IProduct|null|undefined} implementation
                 * @memberof io.cucumber.messages.Meta
                 * @instance
                 */
                Meta.prototype.implementation = null;

                /**
                 * Meta runtime.
                 * @member {io.cucumber.messages.Meta.IProduct|null|undefined} runtime
                 * @memberof io.cucumber.messages.Meta
                 * @instance
                 */
                Meta.prototype.runtime = null;

                /**
                 * Meta os.
                 * @member {io.cucumber.messages.Meta.IProduct|null|undefined} os
                 * @memberof io.cucumber.messages.Meta
                 * @instance
                 */
                Meta.prototype.os = null;

                /**
                 * Meta cpu.
                 * @member {io.cucumber.messages.Meta.IProduct|null|undefined} cpu
                 * @memberof io.cucumber.messages.Meta
                 * @instance
                 */
                Meta.prototype.cpu = null;

                /**
                 * Meta ci.
                 * @member {io.cucumber.messages.Meta.ICI|null|undefined} ci
                 * @memberof io.cucumber.messages.Meta
                 * @instance
                 */
                Meta.prototype.ci = null;

                /**
                 * Creates a new Meta instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Meta
                 * @static
                 * @param {io.cucumber.messages.IMeta=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Meta} Meta instance
                 */
                Meta.create = function create(properties) {
                    return new Meta(properties);
                };

                /**
                 * Encodes the specified Meta message. Does not implicitly {@link io.cucumber.messages.Meta.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Meta
                 * @static
                 * @param {io.cucumber.messages.IMeta} message Meta message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Meta.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.protocolVersion != null && Object.hasOwnProperty.call(message, "protocolVersion"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.protocolVersion);
                    if (message.implementation != null && Object.hasOwnProperty.call(message, "implementation"))
                        $root.io.cucumber.messages.Meta.Product.encode(message.implementation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.runtime != null && Object.hasOwnProperty.call(message, "runtime"))
                        $root.io.cucumber.messages.Meta.Product.encode(message.runtime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.os != null && Object.hasOwnProperty.call(message, "os"))
                        $root.io.cucumber.messages.Meta.Product.encode(message.os, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.cpu != null && Object.hasOwnProperty.call(message, "cpu"))
                        $root.io.cucumber.messages.Meta.Product.encode(message.cpu, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.ci != null && Object.hasOwnProperty.call(message, "ci"))
                        $root.io.cucumber.messages.Meta.CI.encode(message.ci, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Meta message, length delimited. Does not implicitly {@link io.cucumber.messages.Meta.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Meta
                 * @static
                 * @param {io.cucumber.messages.IMeta} message Meta message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Meta.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Meta message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Meta
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Meta} Meta
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Meta.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Meta();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.protocolVersion = reader.string();
                            break;
                        case 2:
                            message.implementation = $root.io.cucumber.messages.Meta.Product.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.runtime = $root.io.cucumber.messages.Meta.Product.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.os = $root.io.cucumber.messages.Meta.Product.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.cpu = $root.io.cucumber.messages.Meta.Product.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.ci = $root.io.cucumber.messages.Meta.CI.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Meta message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Meta
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Meta} Meta
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Meta.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Meta message.
                 * @function verify
                 * @memberof io.cucumber.messages.Meta
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Meta.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.protocolVersion != null && message.hasOwnProperty("protocolVersion"))
                        if (!$util.isString(message.protocolVersion))
                            return "protocolVersion: string expected";
                    if (message.implementation != null && message.hasOwnProperty("implementation")) {
                        var error = $root.io.cucumber.messages.Meta.Product.verify(message.implementation);
                        if (error)
                            return "implementation." + error;
                    }
                    if (message.runtime != null && message.hasOwnProperty("runtime")) {
                        var error = $root.io.cucumber.messages.Meta.Product.verify(message.runtime);
                        if (error)
                            return "runtime." + error;
                    }
                    if (message.os != null && message.hasOwnProperty("os")) {
                        var error = $root.io.cucumber.messages.Meta.Product.verify(message.os);
                        if (error)
                            return "os." + error;
                    }
                    if (message.cpu != null && message.hasOwnProperty("cpu")) {
                        var error = $root.io.cucumber.messages.Meta.Product.verify(message.cpu);
                        if (error)
                            return "cpu." + error;
                    }
                    if (message.ci != null && message.hasOwnProperty("ci")) {
                        var error = $root.io.cucumber.messages.Meta.CI.verify(message.ci);
                        if (error)
                            return "ci." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Meta message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Meta
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Meta} Meta
                 */
                Meta.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Meta)
                        return object;
                    var message = new $root.io.cucumber.messages.Meta();
                    if (object.protocolVersion != null)
                        message.protocolVersion = String(object.protocolVersion);
                    if (object.implementation != null) {
                        if (typeof object.implementation !== "object")
                            throw TypeError(".io.cucumber.messages.Meta.implementation: object expected");
                        message.implementation = $root.io.cucumber.messages.Meta.Product.fromObject(object.implementation);
                    }
                    if (object.runtime != null) {
                        if (typeof object.runtime !== "object")
                            throw TypeError(".io.cucumber.messages.Meta.runtime: object expected");
                        message.runtime = $root.io.cucumber.messages.Meta.Product.fromObject(object.runtime);
                    }
                    if (object.os != null) {
                        if (typeof object.os !== "object")
                            throw TypeError(".io.cucumber.messages.Meta.os: object expected");
                        message.os = $root.io.cucumber.messages.Meta.Product.fromObject(object.os);
                    }
                    if (object.cpu != null) {
                        if (typeof object.cpu !== "object")
                            throw TypeError(".io.cucumber.messages.Meta.cpu: object expected");
                        message.cpu = $root.io.cucumber.messages.Meta.Product.fromObject(object.cpu);
                    }
                    if (object.ci != null) {
                        if (typeof object.ci !== "object")
                            throw TypeError(".io.cucumber.messages.Meta.ci: object expected");
                        message.ci = $root.io.cucumber.messages.Meta.CI.fromObject(object.ci);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Meta message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Meta
                 * @static
                 * @param {io.cucumber.messages.Meta} message Meta
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Meta.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.protocolVersion = "";
                        object.implementation = null;
                        object.runtime = null;
                        object.os = null;
                        object.cpu = null;
                        object.ci = null;
                    }
                    if (message.protocolVersion != null && message.hasOwnProperty("protocolVersion"))
                        object.protocolVersion = message.protocolVersion;
                    if (message.implementation != null && message.hasOwnProperty("implementation"))
                        object.implementation = $root.io.cucumber.messages.Meta.Product.toObject(message.implementation, options);
                    if (message.runtime != null && message.hasOwnProperty("runtime"))
                        object.runtime = $root.io.cucumber.messages.Meta.Product.toObject(message.runtime, options);
                    if (message.os != null && message.hasOwnProperty("os"))
                        object.os = $root.io.cucumber.messages.Meta.Product.toObject(message.os, options);
                    if (message.cpu != null && message.hasOwnProperty("cpu"))
                        object.cpu = $root.io.cucumber.messages.Meta.Product.toObject(message.cpu, options);
                    if (message.ci != null && message.hasOwnProperty("ci"))
                        object.ci = $root.io.cucumber.messages.Meta.CI.toObject(message.ci, options);
                    return object;
                };

                /**
                 * Converts this Meta to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Meta
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Meta.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Meta.Product = (function() {

                    /**
                     * Properties of a Product.
                     * @memberof io.cucumber.messages.Meta
                     * @interface IProduct
                     * @property {string|null} [name] Product name
                     * @property {string|null} [version] Product version
                     */

                    /**
                     * Constructs a new Product.
                     * @memberof io.cucumber.messages.Meta
                     * @classdesc Represents a Product.
                     * @implements IProduct
                     * @constructor
                     * @param {io.cucumber.messages.Meta.IProduct=} [properties] Properties to set
                     */
                    function Product(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Product name.
                     * @member {string} name
                     * @memberof io.cucumber.messages.Meta.Product
                     * @instance
                     */
                    Product.prototype.name = "";

                    /**
                     * Product version.
                     * @member {string} version
                     * @memberof io.cucumber.messages.Meta.Product
                     * @instance
                     */
                    Product.prototype.version = "";

                    /**
                     * Creates a new Product instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.Meta.Product
                     * @static
                     * @param {io.cucumber.messages.Meta.IProduct=} [properties] Properties to set
                     * @returns {io.cucumber.messages.Meta.Product} Product instance
                     */
                    Product.create = function create(properties) {
                        return new Product(properties);
                    };

                    /**
                     * Encodes the specified Product message. Does not implicitly {@link io.cucumber.messages.Meta.Product.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.Meta.Product
                     * @static
                     * @param {io.cucumber.messages.Meta.IProduct} message Product message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Product.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                        return writer;
                    };

                    /**
                     * Encodes the specified Product message, length delimited. Does not implicitly {@link io.cucumber.messages.Meta.Product.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.Meta.Product
                     * @static
                     * @param {io.cucumber.messages.Meta.IProduct} message Product message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Product.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Product message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.Meta.Product
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.Meta.Product} Product
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Product.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Meta.Product();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.version = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Product message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.Meta.Product
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.Meta.Product} Product
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Product.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Product message.
                     * @function verify
                     * @memberof io.cucumber.messages.Meta.Product
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Product.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isString(message.version))
                                return "version: string expected";
                        return null;
                    };

                    /**
                     * Creates a Product message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.Meta.Product
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.Meta.Product} Product
                     */
                    Product.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.Meta.Product)
                            return object;
                        var message = new $root.io.cucumber.messages.Meta.Product();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.version != null)
                            message.version = String(object.version);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Product message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.Meta.Product
                     * @static
                     * @param {io.cucumber.messages.Meta.Product} message Product
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Product.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.version = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        return object;
                    };

                    /**
                     * Converts this Product to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.Meta.Product
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Product.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Product;
                })();

                Meta.CI = (function() {

                    /**
                     * Properties of a CI.
                     * @memberof io.cucumber.messages.Meta
                     * @interface ICI
                     * @property {string|null} [name] CI name
                     * @property {string|null} [url] CI url
                     * @property {io.cucumber.messages.Meta.CI.IGit|null} [git] CI git
                     */

                    /**
                     * Constructs a new CI.
                     * @memberof io.cucumber.messages.Meta
                     * @classdesc Represents a CI.
                     * @implements ICI
                     * @constructor
                     * @param {io.cucumber.messages.Meta.ICI=} [properties] Properties to set
                     */
                    function CI(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CI name.
                     * @member {string} name
                     * @memberof io.cucumber.messages.Meta.CI
                     * @instance
                     */
                    CI.prototype.name = "";

                    /**
                     * CI url.
                     * @member {string} url
                     * @memberof io.cucumber.messages.Meta.CI
                     * @instance
                     */
                    CI.prototype.url = "";

                    /**
                     * CI git.
                     * @member {io.cucumber.messages.Meta.CI.IGit|null|undefined} git
                     * @memberof io.cucumber.messages.Meta.CI
                     * @instance
                     */
                    CI.prototype.git = null;

                    /**
                     * Creates a new CI instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.Meta.CI
                     * @static
                     * @param {io.cucumber.messages.Meta.ICI=} [properties] Properties to set
                     * @returns {io.cucumber.messages.Meta.CI} CI instance
                     */
                    CI.create = function create(properties) {
                        return new CI(properties);
                    };

                    /**
                     * Encodes the specified CI message. Does not implicitly {@link io.cucumber.messages.Meta.CI.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.Meta.CI
                     * @static
                     * @param {io.cucumber.messages.Meta.ICI} message CI message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CI.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                        if (message.git != null && Object.hasOwnProperty.call(message, "git"))
                            $root.io.cucumber.messages.Meta.CI.Git.encode(message.git, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified CI message, length delimited. Does not implicitly {@link io.cucumber.messages.Meta.CI.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.Meta.CI
                     * @static
                     * @param {io.cucumber.messages.Meta.ICI} message CI message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CI.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a CI message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.Meta.CI
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.Meta.CI} CI
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CI.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Meta.CI();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.url = reader.string();
                                break;
                            case 3:
                                message.git = $root.io.cucumber.messages.Meta.CI.Git.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a CI message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.Meta.CI
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.Meta.CI} CI
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CI.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a CI message.
                     * @function verify
                     * @memberof io.cucumber.messages.Meta.CI
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CI.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.url != null && message.hasOwnProperty("url"))
                            if (!$util.isString(message.url))
                                return "url: string expected";
                        if (message.git != null && message.hasOwnProperty("git")) {
                            var error = $root.io.cucumber.messages.Meta.CI.Git.verify(message.git);
                            if (error)
                                return "git." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a CI message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.Meta.CI
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.Meta.CI} CI
                     */
                    CI.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.Meta.CI)
                            return object;
                        var message = new $root.io.cucumber.messages.Meta.CI();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.url != null)
                            message.url = String(object.url);
                        if (object.git != null) {
                            if (typeof object.git !== "object")
                                throw TypeError(".io.cucumber.messages.Meta.CI.git: object expected");
                            message.git = $root.io.cucumber.messages.Meta.CI.Git.fromObject(object.git);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CI message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.Meta.CI
                     * @static
                     * @param {io.cucumber.messages.Meta.CI} message CI
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CI.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.url = "";
                            object.git = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.url != null && message.hasOwnProperty("url"))
                            object.url = message.url;
                        if (message.git != null && message.hasOwnProperty("git"))
                            object.git = $root.io.cucumber.messages.Meta.CI.Git.toObject(message.git, options);
                        return object;
                    };

                    /**
                     * Converts this CI to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.Meta.CI
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CI.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    CI.Git = (function() {

                        /**
                         * Properties of a Git.
                         * @memberof io.cucumber.messages.Meta.CI
                         * @interface IGit
                         * @property {string|null} [remote] Git remote
                         * @property {string|null} [revision] Git revision
                         * @property {string|null} [branch] Git branch
                         * @property {string|null} [tag] Git tag
                         */

                        /**
                         * Constructs a new Git.
                         * @memberof io.cucumber.messages.Meta.CI
                         * @classdesc Represents a Git.
                         * @implements IGit
                         * @constructor
                         * @param {io.cucumber.messages.Meta.CI.IGit=} [properties] Properties to set
                         */
                        function Git(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Git remote.
                         * @member {string} remote
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @instance
                         */
                        Git.prototype.remote = "";

                        /**
                         * Git revision.
                         * @member {string} revision
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @instance
                         */
                        Git.prototype.revision = "";

                        /**
                         * Git branch.
                         * @member {string} branch
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @instance
                         */
                        Git.prototype.branch = "";

                        /**
                         * Git tag.
                         * @member {string} tag
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @instance
                         */
                        Git.prototype.tag = "";

                        /**
                         * Creates a new Git instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @static
                         * @param {io.cucumber.messages.Meta.CI.IGit=} [properties] Properties to set
                         * @returns {io.cucumber.messages.Meta.CI.Git} Git instance
                         */
                        Git.create = function create(properties) {
                            return new Git(properties);
                        };

                        /**
                         * Encodes the specified Git message. Does not implicitly {@link io.cucumber.messages.Meta.CI.Git.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @static
                         * @param {io.cucumber.messages.Meta.CI.IGit} message Git message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Git.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.remote != null && Object.hasOwnProperty.call(message, "remote"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.remote);
                            if (message.revision != null && Object.hasOwnProperty.call(message, "revision"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.revision);
                            if (message.branch != null && Object.hasOwnProperty.call(message, "branch"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.branch);
                            if (message.tag != null && Object.hasOwnProperty.call(message, "tag"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.tag);
                            return writer;
                        };

                        /**
                         * Encodes the specified Git message, length delimited. Does not implicitly {@link io.cucumber.messages.Meta.CI.Git.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @static
                         * @param {io.cucumber.messages.Meta.CI.IGit} message Git message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Git.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Git message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.Meta.CI.Git} Git
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Git.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Meta.CI.Git();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.remote = reader.string();
                                    break;
                                case 2:
                                    message.revision = reader.string();
                                    break;
                                case 3:
                                    message.branch = reader.string();
                                    break;
                                case 4:
                                    message.tag = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Git message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.Meta.CI.Git} Git
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Git.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Git message.
                         * @function verify
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Git.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.remote != null && message.hasOwnProperty("remote"))
                                if (!$util.isString(message.remote))
                                    return "remote: string expected";
                            if (message.revision != null && message.hasOwnProperty("revision"))
                                if (!$util.isString(message.revision))
                                    return "revision: string expected";
                            if (message.branch != null && message.hasOwnProperty("branch"))
                                if (!$util.isString(message.branch))
                                    return "branch: string expected";
                            if (message.tag != null && message.hasOwnProperty("tag"))
                                if (!$util.isString(message.tag))
                                    return "tag: string expected";
                            return null;
                        };

                        /**
                         * Creates a Git message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.Meta.CI.Git} Git
                         */
                        Git.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.Meta.CI.Git)
                                return object;
                            var message = new $root.io.cucumber.messages.Meta.CI.Git();
                            if (object.remote != null)
                                message.remote = String(object.remote);
                            if (object.revision != null)
                                message.revision = String(object.revision);
                            if (object.branch != null)
                                message.branch = String(object.branch);
                            if (object.tag != null)
                                message.tag = String(object.tag);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Git message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @static
                         * @param {io.cucumber.messages.Meta.CI.Git} message Git
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Git.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.remote = "";
                                object.revision = "";
                                object.branch = "";
                                object.tag = "";
                            }
                            if (message.remote != null && message.hasOwnProperty("remote"))
                                object.remote = message.remote;
                            if (message.revision != null && message.hasOwnProperty("revision"))
                                object.revision = message.revision;
                            if (message.branch != null && message.hasOwnProperty("branch"))
                                object.branch = message.branch;
                            if (message.tag != null && message.hasOwnProperty("tag"))
                                object.tag = message.tag;
                            return object;
                        };

                        /**
                         * Converts this Git to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.Meta.CI.Git
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Git.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Git;
                    })();

                    return CI;
                })();

                return Meta;
            })();

            messages.Timestamp = (function() {

                /**
                 * Properties of a Timestamp.
                 * @memberof io.cucumber.messages
                 * @interface ITimestamp
                 * @property {number|null} [seconds] Timestamp seconds
                 * @property {number|null} [nanos] Timestamp nanos
                 */

                /**
                 * Constructs a new Timestamp.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a Timestamp.
                 * @implements ITimestamp
                 * @constructor
                 * @param {io.cucumber.messages.ITimestamp=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Timestamp seconds.
                 * @member {number} seconds
                 * @memberof io.cucumber.messages.Timestamp
                 * @instance
                 */
                Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Timestamp nanos.
                 * @member {number} nanos
                 * @memberof io.cucumber.messages.Timestamp
                 * @instance
                 */
                Timestamp.prototype.nanos = 0;

                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {io.cucumber.messages.ITimestamp=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Timestamp} Timestamp instance
                 */
                Timestamp.create = function create(properties) {
                    return new Timestamp(properties);
                };

                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link io.cucumber.messages.Timestamp.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {io.cucumber.messages.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };

                /**
                 * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link io.cucumber.messages.Timestamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {io.cucumber.messages.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Timestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Timestamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Timestamp message.
                 * @function verify
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };

                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Timestamp} Timestamp
                 */
                Timestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Timestamp)
                        return object;
                    var message = new $root.io.cucumber.messages.Timestamp();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Timestamp
                 * @static
                 * @param {io.cucumber.messages.Timestamp} message Timestamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };

                /**
                 * Converts this Timestamp to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Timestamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Timestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Timestamp;
            })();

            messages.Duration = (function() {

                /**
                 * Properties of a Duration.
                 * @memberof io.cucumber.messages
                 * @interface IDuration
                 * @property {number|null} [seconds] Duration seconds
                 * @property {number|null} [nanos] Duration nanos
                 */

                /**
                 * Constructs a new Duration.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a Duration.
                 * @implements IDuration
                 * @constructor
                 * @param {io.cucumber.messages.IDuration=} [properties] Properties to set
                 */
                function Duration(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Duration seconds.
                 * @member {number} seconds
                 * @memberof io.cucumber.messages.Duration
                 * @instance
                 */
                Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Duration nanos.
                 * @member {number} nanos
                 * @memberof io.cucumber.messages.Duration
                 * @instance
                 */
                Duration.prototype.nanos = 0;

                /**
                 * Creates a new Duration instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {io.cucumber.messages.IDuration=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Duration} Duration instance
                 */
                Duration.create = function create(properties) {
                    return new Duration(properties);
                };

                /**
                 * Encodes the specified Duration message. Does not implicitly {@link io.cucumber.messages.Duration.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {io.cucumber.messages.IDuration} message Duration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };

                /**
                 * Encodes the specified Duration message, length delimited. Does not implicitly {@link io.cucumber.messages.Duration.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {io.cucumber.messages.IDuration} message Duration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duration.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Duration message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Duration} Duration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Duration();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Duration message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Duration} Duration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duration.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Duration message.
                 * @function verify
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Duration.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };

                /**
                 * Creates a Duration message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Duration} Duration
                 */
                Duration.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Duration)
                        return object;
                    var message = new $root.io.cucumber.messages.Duration();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Duration message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Duration
                 * @static
                 * @param {io.cucumber.messages.Duration} message Duration
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Duration.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };

                /**
                 * Converts this Duration to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Duration
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Duration.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Duration;
            })();

            messages.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof io.cucumber.messages
                 * @interface ILocation
                 * @property {number|null} [line] Location line
                 * @property {number|null} [column] Location column
                 */

                /**
                 * Constructs a new Location.
                 * @memberof io.cucumber.messages
                 * @classdesc Points to a line and a column in a text file
                 * @implements ILocation
                 * @constructor
                 * @param {io.cucumber.messages.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location line.
                 * @member {number} line
                 * @memberof io.cucumber.messages.Location
                 * @instance
                 */
                Location.prototype.line = 0;

                /**
                 * Location column.
                 * @member {number} column
                 * @memberof io.cucumber.messages.Location
                 * @instance
                 */
                Location.prototype.column = 0;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {io.cucumber.messages.ILocation=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link io.cucumber.messages.Location.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {io.cucumber.messages.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.line);
                    if (message.column != null && Object.hasOwnProperty.call(message, "column"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.column);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link io.cucumber.messages.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {io.cucumber.messages.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Location();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.line = reader.uint32();
                            break;
                        case 2:
                            message.column = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.line != null && message.hasOwnProperty("line"))
                        if (!$util.isInteger(message.line))
                            return "line: integer expected";
                    if (message.column != null && message.hasOwnProperty("column"))
                        if (!$util.isInteger(message.column))
                            return "column: integer expected";
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Location)
                        return object;
                    var message = new $root.io.cucumber.messages.Location();
                    if (object.line != null)
                        message.line = object.line >>> 0;
                    if (object.column != null)
                        message.column = object.column >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Location
                 * @static
                 * @param {io.cucumber.messages.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.line = 0;
                        object.column = 0;
                    }
                    if (message.line != null && message.hasOwnProperty("line"))
                        object.line = message.line;
                    if (message.column != null && message.hasOwnProperty("column"))
                        object.column = message.column;
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            messages.SourceReference = (function() {

                /**
                 * Properties of a SourceReference.
                 * @memberof io.cucumber.messages
                 * @interface ISourceReference
                 * @property {string|null} [uri] SourceReference uri
                 * @property {io.cucumber.messages.SourceReference.IJavaMethod|null} [javaMethod] SourceReference javaMethod
                 * @property {io.cucumber.messages.SourceReference.IJavaStackTraceElement|null} [javaStackTraceElement] SourceReference javaStackTraceElement
                 * @property {io.cucumber.messages.ILocation|null} [location] SourceReference location
                 */

                /**
                 * Constructs a new SourceReference.
                 * @memberof io.cucumber.messages
                 * @classdesc Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
                 * [Location](#io.cucumber.messages.Location) within that file.
                 * @implements ISourceReference
                 * @constructor
                 * @param {io.cucumber.messages.ISourceReference=} [properties] Properties to set
                 */
                function SourceReference(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SourceReference uri.
                 * @member {string} uri
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 */
                SourceReference.prototype.uri = "";

                /**
                 * SourceReference javaMethod.
                 * @member {io.cucumber.messages.SourceReference.IJavaMethod|null|undefined} javaMethod
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 */
                SourceReference.prototype.javaMethod = null;

                /**
                 * SourceReference javaStackTraceElement.
                 * @member {io.cucumber.messages.SourceReference.IJavaStackTraceElement|null|undefined} javaStackTraceElement
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 */
                SourceReference.prototype.javaStackTraceElement = null;

                /**
                 * SourceReference location.
                 * @member {io.cucumber.messages.ILocation|null|undefined} location
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 */
                SourceReference.prototype.location = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * SourceReference reference.
                 * @member {"uri"|"javaMethod"|"javaStackTraceElement"|undefined} reference
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 */
                Object.defineProperty(SourceReference.prototype, "reference", {
                    get: $util.oneOfGetter($oneOfFields = ["uri", "javaMethod", "javaStackTraceElement"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new SourceReference instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {io.cucumber.messages.ISourceReference=} [properties] Properties to set
                 * @returns {io.cucumber.messages.SourceReference} SourceReference instance
                 */
                SourceReference.create = function create(properties) {
                    return new SourceReference(properties);
                };

                /**
                 * Encodes the specified SourceReference message. Does not implicitly {@link io.cucumber.messages.SourceReference.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {io.cucumber.messages.ISourceReference} message SourceReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceReference.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                        $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.javaMethod != null && Object.hasOwnProperty.call(message, "javaMethod"))
                        $root.io.cucumber.messages.SourceReference.JavaMethod.encode(message.javaMethod, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.javaStackTraceElement != null && Object.hasOwnProperty.call(message, "javaStackTraceElement"))
                        $root.io.cucumber.messages.SourceReference.JavaStackTraceElement.encode(message.javaStackTraceElement, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SourceReference message, length delimited. Does not implicitly {@link io.cucumber.messages.SourceReference.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {io.cucumber.messages.ISourceReference} message SourceReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceReference.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SourceReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.SourceReference} SourceReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceReference.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.SourceReference();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 3:
                            message.javaMethod = $root.io.cucumber.messages.SourceReference.JavaMethod.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.javaStackTraceElement = $root.io.cucumber.messages.SourceReference.JavaStackTraceElement.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SourceReference message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.SourceReference} SourceReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceReference.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SourceReference message.
                 * @function verify
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceReference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.uri != null && message.hasOwnProperty("uri")) {
                        properties.reference = 1;
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    }
                    if (message.javaMethod != null && message.hasOwnProperty("javaMethod")) {
                        if (properties.reference === 1)
                            return "reference: multiple values";
                        properties.reference = 1;
                        {
                            var error = $root.io.cucumber.messages.SourceReference.JavaMethod.verify(message.javaMethod);
                            if (error)
                                return "javaMethod." + error;
                        }
                    }
                    if (message.javaStackTraceElement != null && message.hasOwnProperty("javaStackTraceElement")) {
                        if (properties.reference === 1)
                            return "reference: multiple values";
                        properties.reference = 1;
                        {
                            var error = $root.io.cucumber.messages.SourceReference.JavaStackTraceElement.verify(message.javaStackTraceElement);
                            if (error)
                                return "javaStackTraceElement." + error;
                        }
                    }
                    if (message.location != null && message.hasOwnProperty("location")) {
                        var error = $root.io.cucumber.messages.Location.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SourceReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.SourceReference} SourceReference
                 */
                SourceReference.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.SourceReference)
                        return object;
                    var message = new $root.io.cucumber.messages.SourceReference();
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.javaMethod != null) {
                        if (typeof object.javaMethod !== "object")
                            throw TypeError(".io.cucumber.messages.SourceReference.javaMethod: object expected");
                        message.javaMethod = $root.io.cucumber.messages.SourceReference.JavaMethod.fromObject(object.javaMethod);
                    }
                    if (object.javaStackTraceElement != null) {
                        if (typeof object.javaStackTraceElement !== "object")
                            throw TypeError(".io.cucumber.messages.SourceReference.javaStackTraceElement: object expected");
                        message.javaStackTraceElement = $root.io.cucumber.messages.SourceReference.JavaStackTraceElement.fromObject(object.javaStackTraceElement);
                    }
                    if (object.location != null) {
                        if (typeof object.location !== "object")
                            throw TypeError(".io.cucumber.messages.SourceReference.location: object expected");
                        message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SourceReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.SourceReference
                 * @static
                 * @param {io.cucumber.messages.SourceReference} message SourceReference
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceReference.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.location = null;
                    if (message.uri != null && message.hasOwnProperty("uri")) {
                        object.uri = message.uri;
                        if (options.oneofs)
                            object.reference = "uri";
                    }
                    if (message.location != null && message.hasOwnProperty("location"))
                        object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                    if (message.javaMethod != null && message.hasOwnProperty("javaMethod")) {
                        object.javaMethod = $root.io.cucumber.messages.SourceReference.JavaMethod.toObject(message.javaMethod, options);
                        if (options.oneofs)
                            object.reference = "javaMethod";
                    }
                    if (message.javaStackTraceElement != null && message.hasOwnProperty("javaStackTraceElement")) {
                        object.javaStackTraceElement = $root.io.cucumber.messages.SourceReference.JavaStackTraceElement.toObject(message.javaStackTraceElement, options);
                        if (options.oneofs)
                            object.reference = "javaStackTraceElement";
                    }
                    return object;
                };

                /**
                 * Converts this SourceReference to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.SourceReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                SourceReference.JavaMethod = (function() {

                    /**
                     * Properties of a JavaMethod.
                     * @memberof io.cucumber.messages.SourceReference
                     * @interface IJavaMethod
                     * @property {string|null} [className] JavaMethod className
                     * @property {string|null} [methodName] JavaMethod methodName
                     * @property {Array.<string>|null} [methodParameterTypes] JavaMethod methodParameterTypes
                     */

                    /**
                     * Constructs a new JavaMethod.
                     * @memberof io.cucumber.messages.SourceReference
                     * @classdesc Represents a JavaMethod.
                     * @implements IJavaMethod
                     * @constructor
                     * @param {io.cucumber.messages.SourceReference.IJavaMethod=} [properties] Properties to set
                     */
                    function JavaMethod(properties) {
                        this.methodParameterTypes = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * JavaMethod className.
                     * @member {string} className
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @instance
                     */
                    JavaMethod.prototype.className = "";

                    /**
                     * JavaMethod methodName.
                     * @member {string} methodName
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @instance
                     */
                    JavaMethod.prototype.methodName = "";

                    /**
                     * JavaMethod methodParameterTypes.
                     * @member {Array.<string>} methodParameterTypes
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @instance
                     */
                    JavaMethod.prototype.methodParameterTypes = $util.emptyArray;

                    /**
                     * Creates a new JavaMethod instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @static
                     * @param {io.cucumber.messages.SourceReference.IJavaMethod=} [properties] Properties to set
                     * @returns {io.cucumber.messages.SourceReference.JavaMethod} JavaMethod instance
                     */
                    JavaMethod.create = function create(properties) {
                        return new JavaMethod(properties);
                    };

                    /**
                     * Encodes the specified JavaMethod message. Does not implicitly {@link io.cucumber.messages.SourceReference.JavaMethod.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @static
                     * @param {io.cucumber.messages.SourceReference.IJavaMethod} message JavaMethod message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JavaMethod.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.className != null && Object.hasOwnProperty.call(message, "className"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.className);
                        if (message.methodName != null && Object.hasOwnProperty.call(message, "methodName"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.methodName);
                        if (message.methodParameterTypes != null && message.methodParameterTypes.length)
                            for (var i = 0; i < message.methodParameterTypes.length; ++i)
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.methodParameterTypes[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified JavaMethod message, length delimited. Does not implicitly {@link io.cucumber.messages.SourceReference.JavaMethod.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @static
                     * @param {io.cucumber.messages.SourceReference.IJavaMethod} message JavaMethod message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JavaMethod.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a JavaMethod message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.SourceReference.JavaMethod} JavaMethod
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JavaMethod.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.SourceReference.JavaMethod();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.className = reader.string();
                                break;
                            case 2:
                                message.methodName = reader.string();
                                break;
                            case 3:
                                if (!(message.methodParameterTypes && message.methodParameterTypes.length))
                                    message.methodParameterTypes = [];
                                message.methodParameterTypes.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a JavaMethod message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.SourceReference.JavaMethod} JavaMethod
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JavaMethod.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a JavaMethod message.
                     * @function verify
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    JavaMethod.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.className != null && message.hasOwnProperty("className"))
                            if (!$util.isString(message.className))
                                return "className: string expected";
                        if (message.methodName != null && message.hasOwnProperty("methodName"))
                            if (!$util.isString(message.methodName))
                                return "methodName: string expected";
                        if (message.methodParameterTypes != null && message.hasOwnProperty("methodParameterTypes")) {
                            if (!Array.isArray(message.methodParameterTypes))
                                return "methodParameterTypes: array expected";
                            for (var i = 0; i < message.methodParameterTypes.length; ++i)
                                if (!$util.isString(message.methodParameterTypes[i]))
                                    return "methodParameterTypes: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a JavaMethod message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.SourceReference.JavaMethod} JavaMethod
                     */
                    JavaMethod.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.SourceReference.JavaMethod)
                            return object;
                        var message = new $root.io.cucumber.messages.SourceReference.JavaMethod();
                        if (object.className != null)
                            message.className = String(object.className);
                        if (object.methodName != null)
                            message.methodName = String(object.methodName);
                        if (object.methodParameterTypes) {
                            if (!Array.isArray(object.methodParameterTypes))
                                throw TypeError(".io.cucumber.messages.SourceReference.JavaMethod.methodParameterTypes: array expected");
                            message.methodParameterTypes = [];
                            for (var i = 0; i < object.methodParameterTypes.length; ++i)
                                message.methodParameterTypes[i] = String(object.methodParameterTypes[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a JavaMethod message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @static
                     * @param {io.cucumber.messages.SourceReference.JavaMethod} message JavaMethod
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    JavaMethod.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.methodParameterTypes = [];
                        if (options.defaults) {
                            object.className = "";
                            object.methodName = "";
                        }
                        if (message.className != null && message.hasOwnProperty("className"))
                            object.className = message.className;
                        if (message.methodName != null && message.hasOwnProperty("methodName"))
                            object.methodName = message.methodName;
                        if (message.methodParameterTypes && message.methodParameterTypes.length) {
                            object.methodParameterTypes = [];
                            for (var j = 0; j < message.methodParameterTypes.length; ++j)
                                object.methodParameterTypes[j] = message.methodParameterTypes[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this JavaMethod to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.SourceReference.JavaMethod
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    JavaMethod.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return JavaMethod;
                })();

                SourceReference.JavaStackTraceElement = (function() {

                    /**
                     * Properties of a JavaStackTraceElement.
                     * @memberof io.cucumber.messages.SourceReference
                     * @interface IJavaStackTraceElement
                     * @property {string|null} [className] JavaStackTraceElement className
                     * @property {string|null} [methodName] JavaStackTraceElement methodName
                     * @property {string|null} [fileName] JavaStackTraceElement fileName
                     */

                    /**
                     * Constructs a new JavaStackTraceElement.
                     * @memberof io.cucumber.messages.SourceReference
                     * @classdesc Represents a JavaStackTraceElement.
                     * @implements IJavaStackTraceElement
                     * @constructor
                     * @param {io.cucumber.messages.SourceReference.IJavaStackTraceElement=} [properties] Properties to set
                     */
                    function JavaStackTraceElement(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * JavaStackTraceElement className.
                     * @member {string} className
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @instance
                     */
                    JavaStackTraceElement.prototype.className = "";

                    /**
                     * JavaStackTraceElement methodName.
                     * @member {string} methodName
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @instance
                     */
                    JavaStackTraceElement.prototype.methodName = "";

                    /**
                     * JavaStackTraceElement fileName.
                     * @member {string} fileName
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @instance
                     */
                    JavaStackTraceElement.prototype.fileName = "";

                    /**
                     * Creates a new JavaStackTraceElement instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @static
                     * @param {io.cucumber.messages.SourceReference.IJavaStackTraceElement=} [properties] Properties to set
                     * @returns {io.cucumber.messages.SourceReference.JavaStackTraceElement} JavaStackTraceElement instance
                     */
                    JavaStackTraceElement.create = function create(properties) {
                        return new JavaStackTraceElement(properties);
                    };

                    /**
                     * Encodes the specified JavaStackTraceElement message. Does not implicitly {@link io.cucumber.messages.SourceReference.JavaStackTraceElement.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @static
                     * @param {io.cucumber.messages.SourceReference.IJavaStackTraceElement} message JavaStackTraceElement message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JavaStackTraceElement.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.className != null && Object.hasOwnProperty.call(message, "className"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.className);
                        if (message.methodName != null && Object.hasOwnProperty.call(message, "methodName"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.methodName);
                        if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.fileName);
                        return writer;
                    };

                    /**
                     * Encodes the specified JavaStackTraceElement message, length delimited. Does not implicitly {@link io.cucumber.messages.SourceReference.JavaStackTraceElement.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @static
                     * @param {io.cucumber.messages.SourceReference.IJavaStackTraceElement} message JavaStackTraceElement message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JavaStackTraceElement.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a JavaStackTraceElement message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.SourceReference.JavaStackTraceElement} JavaStackTraceElement
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JavaStackTraceElement.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.SourceReference.JavaStackTraceElement();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.className = reader.string();
                                break;
                            case 2:
                                message.methodName = reader.string();
                                break;
                            case 3:
                                message.fileName = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a JavaStackTraceElement message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.SourceReference.JavaStackTraceElement} JavaStackTraceElement
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JavaStackTraceElement.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a JavaStackTraceElement message.
                     * @function verify
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    JavaStackTraceElement.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.className != null && message.hasOwnProperty("className"))
                            if (!$util.isString(message.className))
                                return "className: string expected";
                        if (message.methodName != null && message.hasOwnProperty("methodName"))
                            if (!$util.isString(message.methodName))
                                return "methodName: string expected";
                        if (message.fileName != null && message.hasOwnProperty("fileName"))
                            if (!$util.isString(message.fileName))
                                return "fileName: string expected";
                        return null;
                    };

                    /**
                     * Creates a JavaStackTraceElement message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.SourceReference.JavaStackTraceElement} JavaStackTraceElement
                     */
                    JavaStackTraceElement.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.SourceReference.JavaStackTraceElement)
                            return object;
                        var message = new $root.io.cucumber.messages.SourceReference.JavaStackTraceElement();
                        if (object.className != null)
                            message.className = String(object.className);
                        if (object.methodName != null)
                            message.methodName = String(object.methodName);
                        if (object.fileName != null)
                            message.fileName = String(object.fileName);
                        return message;
                    };

                    /**
                     * Creates a plain object from a JavaStackTraceElement message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @static
                     * @param {io.cucumber.messages.SourceReference.JavaStackTraceElement} message JavaStackTraceElement
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    JavaStackTraceElement.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.className = "";
                            object.methodName = "";
                            object.fileName = "";
                        }
                        if (message.className != null && message.hasOwnProperty("className"))
                            object.className = message.className;
                        if (message.methodName != null && message.hasOwnProperty("methodName"))
                            object.methodName = message.methodName;
                        if (message.fileName != null && message.hasOwnProperty("fileName"))
                            object.fileName = message.fileName;
                        return object;
                    };

                    /**
                     * Converts this JavaStackTraceElement to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.SourceReference.JavaStackTraceElement
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    JavaStackTraceElement.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return JavaStackTraceElement;
                })();

                return SourceReference;
            })();

            messages.Source = (function() {

                /**
                 * Properties of a Source.
                 * @memberof io.cucumber.messages
                 * @interface ISource
                 * @property {string|null} [uri] The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
                 * of the source, typically a file path relative to the root directory
                 * @property {string|null} [data] Source data
                 * @property {string|null} [mediaType] Source mediaType
                 */

                /**
                 * Constructs a new Source.
                 * @memberof io.cucumber.messages
                 * @classdesc A source file, typically a Gherkin document or Java/Ruby/JavaScript source code
                 * @implements ISource
                 * @constructor
                 * @param {io.cucumber.messages.ISource=} [properties] Properties to set
                 */
                function Source(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
                 * of the source, typically a file path relative to the root directory
                 * @member {string} uri
                 * @memberof io.cucumber.messages.Source
                 * @instance
                 */
                Source.prototype.uri = "";

                /**
                 * Source data.
                 * @member {string} data
                 * @memberof io.cucumber.messages.Source
                 * @instance
                 */
                Source.prototype.data = "";

                /**
                 * Source mediaType.
                 * @member {string} mediaType
                 * @memberof io.cucumber.messages.Source
                 * @instance
                 */
                Source.prototype.mediaType = "";

                /**
                 * Creates a new Source instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {io.cucumber.messages.ISource=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Source} Source instance
                 */
                Source.create = function create(properties) {
                    return new Source(properties);
                };

                /**
                 * Encodes the specified Source message. Does not implicitly {@link io.cucumber.messages.Source.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {io.cucumber.messages.ISource} message Source message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Source.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                    if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.mediaType);
                    return writer;
                };

                /**
                 * Encodes the specified Source message, length delimited. Does not implicitly {@link io.cucumber.messages.Source.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {io.cucumber.messages.ISource} message Source message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Source.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Source message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Source} Source
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Source.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Source();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 2:
                            message.data = reader.string();
                            break;
                        case 3:
                            message.mediaType = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Source message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Source} Source
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Source.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Source message.
                 * @function verify
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Source.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!$util.isString(message.data))
                            return "data: string expected";
                    if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                        if (!$util.isString(message.mediaType))
                            return "mediaType: string expected";
                    return null;
                };

                /**
                 * Creates a Source message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Source} Source
                 */
                Source.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Source)
                        return object;
                    var message = new $root.io.cucumber.messages.Source();
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.data != null)
                        message.data = String(object.data);
                    if (object.mediaType != null)
                        message.mediaType = String(object.mediaType);
                    return message;
                };

                /**
                 * Creates a plain object from a Source message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Source
                 * @static
                 * @param {io.cucumber.messages.Source} message Source
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Source.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.uri = "";
                        object.data = "";
                        object.mediaType = "";
                    }
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = message.data;
                    if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                        object.mediaType = message.mediaType;
                    return object;
                };

                /**
                 * Converts this Source to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Source
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Source.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Source;
            })();

            messages.GherkinDocument = (function() {

                /**
                 * Properties of a GherkinDocument.
                 * @memberof io.cucumber.messages
                 * @interface IGherkinDocument
                 * @property {string|null} [uri] The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
                 * of the source, typically a file path relative to the root directory
                 * @property {io.cucumber.messages.GherkinDocument.IFeature|null} [feature] GherkinDocument feature
                 * @property {Array.<io.cucumber.messages.GherkinDocument.IComment>|null} [comments] GherkinDocument comments
                 */

                /**
                 * Constructs a new GherkinDocument.
                 * @memberof io.cucumber.messages
                 * @classdesc The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
                 * Cucumber implementations should *not* depend on `GherkinDocument` or any of its
                 * children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.
                 * 
                 * The only consumers of `GherkinDocument` should only be formatters that produce
                 * "rich" output, resembling the original Gherkin document.
                 * @implements IGherkinDocument
                 * @constructor
                 * @param {io.cucumber.messages.IGherkinDocument=} [properties] Properties to set
                 */
                function GherkinDocument(properties) {
                    this.comments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
                 * of the source, typically a file path relative to the root directory
                 * @member {string} uri
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @instance
                 */
                GherkinDocument.prototype.uri = "";

                /**
                 * GherkinDocument feature.
                 * @member {io.cucumber.messages.GherkinDocument.IFeature|null|undefined} feature
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @instance
                 */
                GherkinDocument.prototype.feature = null;

                /**
                 * GherkinDocument comments.
                 * @member {Array.<io.cucumber.messages.GherkinDocument.IComment>} comments
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @instance
                 */
                GherkinDocument.prototype.comments = $util.emptyArray;

                /**
                 * Creates a new GherkinDocument instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {io.cucumber.messages.IGherkinDocument=} [properties] Properties to set
                 * @returns {io.cucumber.messages.GherkinDocument} GherkinDocument instance
                 */
                GherkinDocument.create = function create(properties) {
                    return new GherkinDocument(properties);
                };

                /**
                 * Encodes the specified GherkinDocument message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {io.cucumber.messages.IGherkinDocument} message GherkinDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GherkinDocument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uri);
                    if (message.feature != null && Object.hasOwnProperty.call(message, "feature"))
                        $root.io.cucumber.messages.GherkinDocument.Feature.encode(message.feature, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.comments != null && message.comments.length)
                        for (var i = 0; i < message.comments.length; ++i)
                            $root.io.cucumber.messages.GherkinDocument.Comment.encode(message.comments[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GherkinDocument message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {io.cucumber.messages.IGherkinDocument} message GherkinDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GherkinDocument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GherkinDocument message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.GherkinDocument} GherkinDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GherkinDocument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.uri = reader.string();
                            break;
                        case 2:
                            message.feature = $root.io.cucumber.messages.GherkinDocument.Feature.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.comments && message.comments.length))
                                message.comments = [];
                            message.comments.push($root.io.cucumber.messages.GherkinDocument.Comment.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GherkinDocument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.GherkinDocument} GherkinDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GherkinDocument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GherkinDocument message.
                 * @function verify
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GherkinDocument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.feature != null && message.hasOwnProperty("feature")) {
                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.verify(message.feature);
                        if (error)
                            return "feature." + error;
                    }
                    if (message.comments != null && message.hasOwnProperty("comments")) {
                        if (!Array.isArray(message.comments))
                            return "comments: array expected";
                        for (var i = 0; i < message.comments.length; ++i) {
                            var error = $root.io.cucumber.messages.GherkinDocument.Comment.verify(message.comments[i]);
                            if (error)
                                return "comments." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GherkinDocument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.GherkinDocument} GherkinDocument
                 */
                GherkinDocument.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.GherkinDocument)
                        return object;
                    var message = new $root.io.cucumber.messages.GherkinDocument();
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.feature != null) {
                        if (typeof object.feature !== "object")
                            throw TypeError(".io.cucumber.messages.GherkinDocument.feature: object expected");
                        message.feature = $root.io.cucumber.messages.GherkinDocument.Feature.fromObject(object.feature);
                    }
                    if (object.comments) {
                        if (!Array.isArray(object.comments))
                            throw TypeError(".io.cucumber.messages.GherkinDocument.comments: array expected");
                        message.comments = [];
                        for (var i = 0; i < object.comments.length; ++i) {
                            if (typeof object.comments[i] !== "object")
                                throw TypeError(".io.cucumber.messages.GherkinDocument.comments: object expected");
                            message.comments[i] = $root.io.cucumber.messages.GherkinDocument.Comment.fromObject(object.comments[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GherkinDocument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @static
                 * @param {io.cucumber.messages.GherkinDocument} message GherkinDocument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GherkinDocument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.comments = [];
                    if (options.defaults) {
                        object.uri = "";
                        object.feature = null;
                    }
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.feature != null && message.hasOwnProperty("feature"))
                        object.feature = $root.io.cucumber.messages.GherkinDocument.Feature.toObject(message.feature, options);
                    if (message.comments && message.comments.length) {
                        object.comments = [];
                        for (var j = 0; j < message.comments.length; ++j)
                            object.comments[j] = $root.io.cucumber.messages.GherkinDocument.Comment.toObject(message.comments[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GherkinDocument to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.GherkinDocument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GherkinDocument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                GherkinDocument.Comment = (function() {

                    /**
                     * Properties of a Comment.
                     * @memberof io.cucumber.messages.GherkinDocument
                     * @interface IComment
                     * @property {io.cucumber.messages.ILocation|null} [location] Comment location
                     * @property {string|null} [text] Comment text
                     */

                    /**
                     * Constructs a new Comment.
                     * @memberof io.cucumber.messages.GherkinDocument
                     * @classdesc A comment in a Gherkin document
                     * @implements IComment
                     * @constructor
                     * @param {io.cucumber.messages.GherkinDocument.IComment=} [properties] Properties to set
                     */
                    function Comment(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Comment location.
                     * @member {io.cucumber.messages.ILocation|null|undefined} location
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @instance
                     */
                    Comment.prototype.location = null;

                    /**
                     * Comment text.
                     * @member {string} text
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @instance
                     */
                    Comment.prototype.text = "";

                    /**
                     * Creates a new Comment instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IComment=} [properties] Properties to set
                     * @returns {io.cucumber.messages.GherkinDocument.Comment} Comment instance
                     */
                    Comment.create = function create(properties) {
                        return new Comment(properties);
                    };

                    /**
                     * Encodes the specified Comment message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Comment.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IComment} message Comment message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Comment.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                            $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                        return writer;
                    };

                    /**
                     * Encodes the specified Comment message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Comment.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IComment} message Comment message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Comment.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Comment message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.GherkinDocument.Comment} Comment
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Comment.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Comment();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.text = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Comment message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.GherkinDocument.Comment} Comment
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Comment.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Comment message.
                     * @function verify
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Comment.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.location != null && message.hasOwnProperty("location")) {
                            var error = $root.io.cucumber.messages.Location.verify(message.location);
                            if (error)
                                return "location." + error;
                        }
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        return null;
                    };

                    /**
                     * Creates a Comment message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.GherkinDocument.Comment} Comment
                     */
                    Comment.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.GherkinDocument.Comment)
                            return object;
                        var message = new $root.io.cucumber.messages.GherkinDocument.Comment();
                        if (object.location != null) {
                            if (typeof object.location !== "object")
                                throw TypeError(".io.cucumber.messages.GherkinDocument.Comment.location: object expected");
                            message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                        }
                        if (object.text != null)
                            message.text = String(object.text);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Comment message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.Comment} message Comment
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Comment.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.location = null;
                            object.text = "";
                        }
                        if (message.location != null && message.hasOwnProperty("location"))
                            object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        return object;
                    };

                    /**
                     * Converts this Comment to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.GherkinDocument.Comment
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Comment.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Comment;
                })();

                GherkinDocument.Feature = (function() {

                    /**
                     * Properties of a Feature.
                     * @memberof io.cucumber.messages.GherkinDocument
                     * @interface IFeature
                     * @property {io.cucumber.messages.ILocation|null} [location] Feature location
                     * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>|null} [tags] Feature tags
                     * @property {string|null} [language] Feature language
                     * @property {string|null} [keyword] Feature keyword
                     * @property {string|null} [name] Feature name
                     * @property {string|null} [description] Feature description
                     * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.IFeatureChild>|null} [children] Feature children
                     */

                    /**
                     * Constructs a new Feature.
                     * @memberof io.cucumber.messages.GherkinDocument
                     * @classdesc The top level node in the AST
                     * @implements IFeature
                     * @constructor
                     * @param {io.cucumber.messages.GherkinDocument.IFeature=} [properties] Properties to set
                     */
                    function Feature(properties) {
                        this.tags = [];
                        this.children = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Feature location.
                     * @member {io.cucumber.messages.ILocation|null|undefined} location
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.location = null;

                    /**
                     * Feature tags.
                     * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>} tags
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.tags = $util.emptyArray;

                    /**
                     * Feature language.
                     * @member {string} language
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.language = "";

                    /**
                     * Feature keyword.
                     * @member {string} keyword
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.keyword = "";

                    /**
                     * Feature name.
                     * @member {string} name
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.name = "";

                    /**
                     * Feature description.
                     * @member {string} description
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.description = "";

                    /**
                     * Feature children.
                     * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.IFeatureChild>} children
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     */
                    Feature.prototype.children = $util.emptyArray;

                    /**
                     * Creates a new Feature instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IFeature=} [properties] Properties to set
                     * @returns {io.cucumber.messages.GherkinDocument.Feature} Feature instance
                     */
                    Feature.create = function create(properties) {
                        return new Feature(properties);
                    };

                    /**
                     * Encodes the specified Feature message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IFeature} message Feature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Feature.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                            $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.tags != null && message.tags.length)
                            for (var i = 0; i < message.tags.length; ++i)
                                $root.io.cucumber.messages.GherkinDocument.Feature.Tag.encode(message.tags[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.language);
                        if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.keyword);
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
                        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
                        if (message.children != null && message.children.length)
                            for (var i = 0; i < message.children.length; ++i)
                                $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.encode(message.children[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Feature message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.IFeature} message Feature message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Feature.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Feature message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.GherkinDocument.Feature} Feature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Feature.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                break;
                            case 2:
                                if (!(message.tags && message.tags.length))
                                    message.tags = [];
                                message.tags.push($root.io.cucumber.messages.GherkinDocument.Feature.Tag.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.language = reader.string();
                                break;
                            case 4:
                                message.keyword = reader.string();
                                break;
                            case 5:
                                message.name = reader.string();
                                break;
                            case 6:
                                message.description = reader.string();
                                break;
                            case 7:
                                if (!(message.children && message.children.length))
                                    message.children = [];
                                message.children.push($root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Feature message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.GherkinDocument.Feature} Feature
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Feature.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Feature message.
                     * @function verify
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Feature.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.location != null && message.hasOwnProperty("location")) {
                            var error = $root.io.cucumber.messages.Location.verify(message.location);
                            if (error)
                                return "location." + error;
                        }
                        if (message.tags != null && message.hasOwnProperty("tags")) {
                            if (!Array.isArray(message.tags))
                                return "tags: array expected";
                            for (var i = 0; i < message.tags.length; ++i) {
                                var error = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.verify(message.tags[i]);
                                if (error)
                                    return "tags." + error;
                            }
                        }
                        if (message.language != null && message.hasOwnProperty("language"))
                            if (!$util.isString(message.language))
                                return "language: string expected";
                        if (message.keyword != null && message.hasOwnProperty("keyword"))
                            if (!$util.isString(message.keyword))
                                return "keyword: string expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        if (message.children != null && message.hasOwnProperty("children")) {
                            if (!Array.isArray(message.children))
                                return "children: array expected";
                            for (var i = 0; i < message.children.length; ++i) {
                                var error = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.verify(message.children[i]);
                                if (error)
                                    return "children." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Feature message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.GherkinDocument.Feature} Feature
                     */
                    Feature.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature)
                            return object;
                        var message = new $root.io.cucumber.messages.GherkinDocument.Feature();
                        if (object.location != null) {
                            if (typeof object.location !== "object")
                                throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.location: object expected");
                            message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                        }
                        if (object.tags) {
                            if (!Array.isArray(object.tags))
                                throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.tags: array expected");
                            message.tags = [];
                            for (var i = 0; i < object.tags.length; ++i) {
                                if (typeof object.tags[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.tags: object expected");
                                message.tags[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.fromObject(object.tags[i]);
                            }
                        }
                        if (object.language != null)
                            message.language = String(object.language);
                        if (object.keyword != null)
                            message.keyword = String(object.keyword);
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.description != null)
                            message.description = String(object.description);
                        if (object.children) {
                            if (!Array.isArray(object.children))
                                throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.children: array expected");
                            message.children = [];
                            for (var i = 0; i < object.children.length; ++i) {
                                if (typeof object.children[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.children: object expected");
                                message.children[i] = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.fromObject(object.children[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Feature message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @static
                     * @param {io.cucumber.messages.GherkinDocument.Feature} message Feature
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Feature.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.tags = [];
                            object.children = [];
                        }
                        if (options.defaults) {
                            object.location = null;
                            object.language = "";
                            object.keyword = "";
                            object.name = "";
                            object.description = "";
                        }
                        if (message.location != null && message.hasOwnProperty("location"))
                            object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                        if (message.tags && message.tags.length) {
                            object.tags = [];
                            for (var j = 0; j < message.tags.length; ++j)
                                object.tags[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.toObject(message.tags[j], options);
                        }
                        if (message.language != null && message.hasOwnProperty("language"))
                            object.language = message.language;
                        if (message.keyword != null && message.hasOwnProperty("keyword"))
                            object.keyword = message.keyword;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        if (message.children && message.children.length) {
                            object.children = [];
                            for (var j = 0; j < message.children.length; ++j)
                                object.children[j] = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.toObject(message.children[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Feature to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.GherkinDocument.Feature
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Feature.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Feature.Tag = (function() {

                        /**
                         * Properties of a Tag.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface ITag
                         * @property {io.cucumber.messages.ILocation|null} [location] Tag location
                         * @property {string|null} [name] Tag name
                         * @property {string|null} [id] Tag id
                         */

                        /**
                         * Constructs a new Tag.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc A tag
                         * @implements ITag
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITag=} [properties] Properties to set
                         */
                        function Tag(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Tag location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @instance
                         */
                        Tag.prototype.location = null;

                        /**
                         * Tag name.
                         * @member {string} name
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @instance
                         */
                        Tag.prototype.name = "";

                        /**
                         * Tag id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @instance
                         */
                        Tag.prototype.id = "";

                        /**
                         * Creates a new Tag instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITag=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Tag} Tag instance
                         */
                        Tag.create = function create(properties) {
                            return new Tag(properties);
                        };

                        /**
                         * Encodes the specified Tag message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Tag.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITag} message Tag message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Tag.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified Tag message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Tag.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITag} message Tag message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Tag.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Tag message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Tag} Tag
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Tag.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Tag();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.name = reader.string();
                                    break;
                                case 3:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Tag message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Tag} Tag
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Tag.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Tag message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Tag.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a Tag message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Tag} Tag
                         */
                        Tag.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Tag)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Tag();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Tag.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Tag message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.Tag} message Tag
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Tag.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.location = null;
                                object.name = "";
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this Tag to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Tag
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Tag.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Tag;
                    })();

                    Feature.FeatureChild = (function() {

                        /**
                         * Properties of a FeatureChild.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface IFeatureChild
                         * @property {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule|null} [rule] FeatureChild rule
                         * @property {io.cucumber.messages.GherkinDocument.Feature.IBackground|null} [background] FeatureChild background
                         * @property {io.cucumber.messages.GherkinDocument.Feature.IScenario|null} [scenario] FeatureChild scenario
                         */

                        /**
                         * Constructs a new FeatureChild.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc A child node of a `Feature` node
                         * @implements IFeatureChild
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IFeatureChild=} [properties] Properties to set
                         */
                        function FeatureChild(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FeatureChild rule.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule|null|undefined} rule
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         */
                        FeatureChild.prototype.rule = null;

                        /**
                         * FeatureChild background.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.IBackground|null|undefined} background
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         */
                        FeatureChild.prototype.background = null;

                        /**
                         * FeatureChild scenario.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.IScenario|null|undefined} scenario
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         */
                        FeatureChild.prototype.scenario = null;

                        // OneOf field names bound to virtual getters and setters
                        var $oneOfFields;

                        /**
                         * FeatureChild value.
                         * @member {"rule"|"background"|"scenario"|undefined} value
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         */
                        Object.defineProperty(FeatureChild.prototype, "value", {
                            get: $util.oneOfGetter($oneOfFields = ["rule", "background", "scenario"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new FeatureChild instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IFeatureChild=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} FeatureChild instance
                         */
                        FeatureChild.create = function create(properties) {
                            return new FeatureChild(properties);
                        };

                        /**
                         * Encodes the specified FeatureChild message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IFeatureChild} message FeatureChild message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FeatureChild.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.rule != null && Object.hasOwnProperty.call(message, "rule"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.encode(message.rule, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.Background.encode(message.background, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.scenario != null && Object.hasOwnProperty.call(message, "scenario"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.encode(message.scenario, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified FeatureChild message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IFeatureChild} message FeatureChild message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FeatureChild.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FeatureChild message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} FeatureChild
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FeatureChild.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.rule = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.decode(reader, reader.uint32());
                                    break;
                                case 3:
                                    message.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FeatureChild message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} FeatureChild
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FeatureChild.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FeatureChild message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FeatureChild.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            var properties = {};
                            if (message.rule != null && message.hasOwnProperty("rule")) {
                                properties.value = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.verify(message.rule);
                                    if (error)
                                        return "rule." + error;
                                }
                            }
                            if (message.background != null && message.hasOwnProperty("background")) {
                                if (properties.value === 1)
                                    return "value: multiple values";
                                properties.value = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Background.verify(message.background);
                                    if (error)
                                        return "background." + error;
                                }
                            }
                            if (message.scenario != null && message.hasOwnProperty("scenario")) {
                                if (properties.value === 1)
                                    return "value: multiple values";
                                properties.value = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.verify(message.scenario);
                                    if (error)
                                        return "scenario." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a FeatureChild message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} FeatureChild
                         */
                        FeatureChild.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild();
                            if (object.rule != null) {
                                if (typeof object.rule !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.rule: object expected");
                                message.rule = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.fromObject(object.rule);
                            }
                            if (object.background != null) {
                                if (typeof object.background !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.background: object expected");
                                message.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.fromObject(object.background);
                            }
                            if (object.scenario != null) {
                                if (typeof object.scenario !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.scenario: object expected");
                                message.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.fromObject(object.scenario);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FeatureChild message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild} message FeatureChild
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FeatureChild.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (message.rule != null && message.hasOwnProperty("rule")) {
                                object.rule = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.toObject(message.rule, options);
                                if (options.oneofs)
                                    object.value = "rule";
                            }
                            if (message.background != null && message.hasOwnProperty("background")) {
                                object.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.toObject(message.background, options);
                                if (options.oneofs)
                                    object.value = "background";
                            }
                            if (message.scenario != null && message.hasOwnProperty("scenario")) {
                                object.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.toObject(message.scenario, options);
                                if (options.oneofs)
                                    object.value = "scenario";
                            }
                            return object;
                        };

                        /**
                         * Converts this FeatureChild to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FeatureChild.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        FeatureChild.Rule = (function() {

                            /**
                             * Properties of a Rule.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                             * @interface IRule
                             * @property {io.cucumber.messages.ILocation|null} [location] Rule location
                             * @property {string|null} [keyword] Rule keyword
                             * @property {string|null} [name] Rule name
                             * @property {string|null} [description] Rule description
                             * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild>|null} [children] Rule children
                             * @property {string|null} [id] Rule id
                             */

                            /**
                             * Constructs a new Rule.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                             * @classdesc A `Rule` node
                             * @implements IRule
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule=} [properties] Properties to set
                             */
                            function Rule(properties) {
                                this.children = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Rule location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.location = null;

                            /**
                             * Rule keyword.
                             * @member {string} keyword
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.keyword = "";

                            /**
                             * Rule name.
                             * @member {string} name
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.name = "";

                            /**
                             * Rule description.
                             * @member {string} description
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.description = "";

                            /**
                             * Rule children.
                             * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild>} children
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.children = $util.emptyArray;

                            /**
                             * Rule id.
                             * @member {string} id
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             */
                            Rule.prototype.id = "";

                            /**
                             * Creates a new Rule instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} Rule instance
                             */
                            Rule.create = function create(properties) {
                                return new Rule(properties);
                            };

                            /**
                             * Encodes the specified Rule message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule} message Rule message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Rule.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyword);
                                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                                if (message.children != null && message.children.length)
                                    for (var i = 0; i < message.children.length; ++i)
                                        $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.encode(message.children[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.id);
                                return writer;
                            };

                            /**
                             * Encodes the specified Rule message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRule} message Rule message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Rule.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Rule message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} Rule
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Rule.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.keyword = reader.string();
                                        break;
                                    case 3:
                                        message.name = reader.string();
                                        break;
                                    case 4:
                                        message.description = reader.string();
                                        break;
                                    case 5:
                                        if (!(message.children && message.children.length))
                                            message.children = [];
                                        message.children.push($root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.decode(reader, reader.uint32()));
                                        break;
                                    case 6:
                                        message.id = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Rule message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} Rule
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Rule.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Rule message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Rule.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    if (!$util.isString(message.keyword))
                                        return "keyword: string expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                if (message.children != null && message.hasOwnProperty("children")) {
                                    if (!Array.isArray(message.children))
                                        return "children: array expected";
                                    for (var i = 0; i < message.children.length; ++i) {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.verify(message.children[i]);
                                        if (error)
                                            return "children." + error;
                                    }
                                }
                                if (message.id != null && message.hasOwnProperty("id"))
                                    if (!$util.isString(message.id))
                                        return "id: string expected";
                                return null;
                            };

                            /**
                             * Creates a Rule message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} Rule
                             */
                            Rule.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.keyword != null)
                                    message.keyword = String(object.keyword);
                                if (object.name != null)
                                    message.name = String(object.name);
                                if (object.description != null)
                                    message.description = String(object.description);
                                if (object.children) {
                                    if (!Array.isArray(object.children))
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.children: array expected");
                                    message.children = [];
                                    for (var i = 0; i < object.children.length; ++i) {
                                        if (typeof object.children[i] !== "object")
                                            throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule.children: object expected");
                                        message.children[i] = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.fromObject(object.children[i]);
                                    }
                                }
                                if (object.id != null)
                                    message.id = String(object.id);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Rule message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule} message Rule
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Rule.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults)
                                    object.children = [];
                                if (options.defaults) {
                                    object.location = null;
                                    object.keyword = "";
                                    object.name = "";
                                    object.description = "";
                                    object.id = "";
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    object.keyword = message.keyword;
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                if (message.children && message.children.length) {
                                    object.children = [];
                                    for (var j = 0; j < message.children.length; ++j)
                                        object.children[j] = $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.toObject(message.children[j], options);
                                }
                                if (message.id != null && message.hasOwnProperty("id"))
                                    object.id = message.id;
                                return object;
                            };

                            /**
                             * Converts this Rule to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Rule.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Rule;
                        })();

                        FeatureChild.RuleChild = (function() {

                            /**
                             * Properties of a RuleChild.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                             * @interface IRuleChild
                             * @property {io.cucumber.messages.GherkinDocument.Feature.IBackground|null} [background] RuleChild background
                             * @property {io.cucumber.messages.GherkinDocument.Feature.IScenario|null} [scenario] RuleChild scenario
                             */

                            /**
                             * Constructs a new RuleChild.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild
                             * @classdesc Represents a RuleChild.
                             * @implements IRuleChild
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild=} [properties] Properties to set
                             */
                            function RuleChild(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * RuleChild background.
                             * @member {io.cucumber.messages.GherkinDocument.Feature.IBackground|null|undefined} background
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @instance
                             */
                            RuleChild.prototype.background = null;

                            /**
                             * RuleChild scenario.
                             * @member {io.cucumber.messages.GherkinDocument.Feature.IScenario|null|undefined} scenario
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @instance
                             */
                            RuleChild.prototype.scenario = null;

                            // OneOf field names bound to virtual getters and setters
                            var $oneOfFields;

                            /**
                             * RuleChild value.
                             * @member {"background"|"scenario"|undefined} value
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @instance
                             */
                            Object.defineProperty(RuleChild.prototype, "value", {
                                get: $util.oneOfGetter($oneOfFields = ["background", "scenario"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Creates a new RuleChild instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} RuleChild instance
                             */
                            RuleChild.create = function create(properties) {
                                return new RuleChild(properties);
                            };

                            /**
                             * Encodes the specified RuleChild message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild} message RuleChild message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RuleChild.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.background != null && Object.hasOwnProperty.call(message, "background"))
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Background.encode(message.background, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.scenario != null && Object.hasOwnProperty.call(message, "scenario"))
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.encode(message.scenario, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified RuleChild message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.IRuleChild} message RuleChild message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            RuleChild.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a RuleChild message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} RuleChild
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RuleChild.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a RuleChild message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} RuleChild
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            RuleChild.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a RuleChild message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            RuleChild.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                var properties = {};
                                if (message.background != null && message.hasOwnProperty("background")) {
                                    properties.value = 1;
                                    {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.Background.verify(message.background);
                                        if (error)
                                            return "background." + error;
                                    }
                                }
                                if (message.scenario != null && message.hasOwnProperty("scenario")) {
                                    if (properties.value === 1)
                                        return "value: multiple values";
                                    properties.value = 1;
                                    {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.verify(message.scenario);
                                        if (error)
                                            return "scenario." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates a RuleChild message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} RuleChild
                             */
                            RuleChild.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild();
                                if (object.background != null) {
                                    if (typeof object.background !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.background: object expected");
                                    message.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.fromObject(object.background);
                                }
                                if (object.scenario != null) {
                                    if (typeof object.scenario !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild.scenario: object expected");
                                    message.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.fromObject(object.scenario);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a RuleChild message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild} message RuleChild
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            RuleChild.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (message.background != null && message.hasOwnProperty("background")) {
                                    object.background = $root.io.cucumber.messages.GherkinDocument.Feature.Background.toObject(message.background, options);
                                    if (options.oneofs)
                                        object.value = "background";
                                }
                                if (message.scenario != null && message.hasOwnProperty("scenario")) {
                                    object.scenario = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.toObject(message.scenario, options);
                                    if (options.oneofs)
                                        object.value = "scenario";
                                }
                                return object;
                            };

                            /**
                             * Converts this RuleChild to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            RuleChild.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return RuleChild;
                        })();

                        return FeatureChild;
                    })();

                    Feature.Background = (function() {

                        /**
                         * Properties of a Background.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface IBackground
                         * @property {io.cucumber.messages.ILocation|null} [location] Background location
                         * @property {string|null} [keyword] Background keyword
                         * @property {string|null} [name] Background name
                         * @property {string|null} [description] Background description
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.IStep>|null} [steps] Background steps
                         * @property {string|null} [id] Background id
                         */

                        /**
                         * Constructs a new Background.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc Represents a Background.
                         * @implements IBackground
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IBackground=} [properties] Properties to set
                         */
                        function Background(properties) {
                            this.steps = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Background location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.location = null;

                        /**
                         * Background keyword.
                         * @member {string} keyword
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.keyword = "";

                        /**
                         * Background name.
                         * @member {string} name
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.name = "";

                        /**
                         * Background description.
                         * @member {string} description
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.description = "";

                        /**
                         * Background steps.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.IStep>} steps
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.steps = $util.emptyArray;

                        /**
                         * Background id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         */
                        Background.prototype.id = "";

                        /**
                         * Creates a new Background instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IBackground=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Background} Background instance
                         */
                        Background.create = function create(properties) {
                            return new Background(properties);
                        };

                        /**
                         * Encodes the specified Background message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Background.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IBackground} message Background message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Background.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyword);
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                            if (message.steps != null && message.steps.length)
                                for (var i = 0; i < message.steps.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Step.encode(message.steps[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified Background message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Background.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IBackground} message Background message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Background.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Background message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Background} Background
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Background.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Background();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.keyword = reader.string();
                                    break;
                                case 3:
                                    message.name = reader.string();
                                    break;
                                case 4:
                                    message.description = reader.string();
                                    break;
                                case 5:
                                    if (!(message.steps && message.steps.length))
                                        message.steps = [];
                                    message.steps.push($root.io.cucumber.messages.GherkinDocument.Feature.Step.decode(reader, reader.uint32()));
                                    break;
                                case 6:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Background message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Background} Background
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Background.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Background message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Background.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                if (!$util.isString(message.keyword))
                                    return "keyword: string expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            if (message.steps != null && message.hasOwnProperty("steps")) {
                                if (!Array.isArray(message.steps))
                                    return "steps: array expected";
                                for (var i = 0; i < message.steps.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Step.verify(message.steps[i]);
                                    if (error)
                                        return "steps." + error;
                                }
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a Background message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Background} Background
                         */
                        Background.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Background)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Background();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Background.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.keyword != null)
                                message.keyword = String(object.keyword);
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.description != null)
                                message.description = String(object.description);
                            if (object.steps) {
                                if (!Array.isArray(object.steps))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Background.steps: array expected");
                                message.steps = [];
                                for (var i = 0; i < object.steps.length; ++i) {
                                    if (typeof object.steps[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Background.steps: object expected");
                                    message.steps[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Step.fromObject(object.steps[i]);
                                }
                            }
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Background message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.Background} message Background
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Background.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.steps = [];
                            if (options.defaults) {
                                object.location = null;
                                object.keyword = "";
                                object.name = "";
                                object.description = "";
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                object.keyword = message.keyword;
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            if (message.steps && message.steps.length) {
                                object.steps = [];
                                for (var j = 0; j < message.steps.length; ++j)
                                    object.steps[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Step.toObject(message.steps[j], options);
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this Background to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Background
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Background.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Background;
                    })();

                    Feature.Scenario = (function() {

                        /**
                         * Properties of a Scenario.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface IScenario
                         * @property {io.cucumber.messages.ILocation|null} [location] Scenario location
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>|null} [tags] Scenario tags
                         * @property {string|null} [keyword] Scenario keyword
                         * @property {string|null} [name] Scenario name
                         * @property {string|null} [description] Scenario description
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.IStep>|null} [steps] Scenario steps
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples>|null} [examples] Scenario examples
                         * @property {string|null} [id] Scenario id
                         */

                        /**
                         * Constructs a new Scenario.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc Represents a Scenario.
                         * @implements IScenario
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IScenario=} [properties] Properties to set
                         */
                        function Scenario(properties) {
                            this.tags = [];
                            this.steps = [];
                            this.examples = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Scenario location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.location = null;

                        /**
                         * Scenario tags.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>} tags
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.tags = $util.emptyArray;

                        /**
                         * Scenario keyword.
                         * @member {string} keyword
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.keyword = "";

                        /**
                         * Scenario name.
                         * @member {string} name
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.name = "";

                        /**
                         * Scenario description.
                         * @member {string} description
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.description = "";

                        /**
                         * Scenario steps.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.IStep>} steps
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.steps = $util.emptyArray;

                        /**
                         * Scenario examples.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples>} examples
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.examples = $util.emptyArray;

                        /**
                         * Scenario id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         */
                        Scenario.prototype.id = "";

                        /**
                         * Creates a new Scenario instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IScenario=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario} Scenario instance
                         */
                        Scenario.create = function create(properties) {
                            return new Scenario(properties);
                        };

                        /**
                         * Encodes the specified Scenario message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Scenario.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IScenario} message Scenario message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Scenario.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.tags != null && message.tags.length)
                                for (var i = 0; i < message.tags.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Tag.encode(message.tags[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyword);
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                            if (message.steps != null && message.steps.length)
                                for (var i = 0; i < message.steps.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Step.encode(message.steps[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.examples != null && message.examples.length)
                                for (var i = 0; i < message.examples.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.encode(message.examples[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                                writer.uint32(/* id 8, wireType 2 =*/66).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified Scenario message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Scenario.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IScenario} message Scenario message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Scenario.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Scenario message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario} Scenario
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Scenario.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Scenario();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    if (!(message.tags && message.tags.length))
                                        message.tags = [];
                                    message.tags.push($root.io.cucumber.messages.GherkinDocument.Feature.Tag.decode(reader, reader.uint32()));
                                    break;
                                case 3:
                                    message.keyword = reader.string();
                                    break;
                                case 4:
                                    message.name = reader.string();
                                    break;
                                case 5:
                                    message.description = reader.string();
                                    break;
                                case 6:
                                    if (!(message.steps && message.steps.length))
                                        message.steps = [];
                                    message.steps.push($root.io.cucumber.messages.GherkinDocument.Feature.Step.decode(reader, reader.uint32()));
                                    break;
                                case 7:
                                    if (!(message.examples && message.examples.length))
                                        message.examples = [];
                                    message.examples.push($root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.decode(reader, reader.uint32()));
                                    break;
                                case 8:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Scenario message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario} Scenario
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Scenario.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Scenario message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Scenario.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.tags != null && message.hasOwnProperty("tags")) {
                                if (!Array.isArray(message.tags))
                                    return "tags: array expected";
                                for (var i = 0; i < message.tags.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.verify(message.tags[i]);
                                    if (error)
                                        return "tags." + error;
                                }
                            }
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                if (!$util.isString(message.keyword))
                                    return "keyword: string expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            if (message.steps != null && message.hasOwnProperty("steps")) {
                                if (!Array.isArray(message.steps))
                                    return "steps: array expected";
                                for (var i = 0; i < message.steps.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Step.verify(message.steps[i]);
                                    if (error)
                                        return "steps." + error;
                                }
                            }
                            if (message.examples != null && message.hasOwnProperty("examples")) {
                                if (!Array.isArray(message.examples))
                                    return "examples: array expected";
                                for (var i = 0; i < message.examples.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.verify(message.examples[i]);
                                    if (error)
                                        return "examples." + error;
                                }
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a Scenario message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario} Scenario
                         */
                        Scenario.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Scenario)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Scenario();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.tags) {
                                if (!Array.isArray(object.tags))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.tags: array expected");
                                message.tags = [];
                                for (var i = 0; i < object.tags.length; ++i) {
                                    if (typeof object.tags[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.tags: object expected");
                                    message.tags[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.fromObject(object.tags[i]);
                                }
                            }
                            if (object.keyword != null)
                                message.keyword = String(object.keyword);
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.description != null)
                                message.description = String(object.description);
                            if (object.steps) {
                                if (!Array.isArray(object.steps))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.steps: array expected");
                                message.steps = [];
                                for (var i = 0; i < object.steps.length; ++i) {
                                    if (typeof object.steps[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.steps: object expected");
                                    message.steps[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Step.fromObject(object.steps[i]);
                                }
                            }
                            if (object.examples) {
                                if (!Array.isArray(object.examples))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.examples: array expected");
                                message.examples = [];
                                for (var i = 0; i < object.examples.length; ++i) {
                                    if (typeof object.examples[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.examples: object expected");
                                    message.examples[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.fromObject(object.examples[i]);
                                }
                            }
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Scenario message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario} message Scenario
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Scenario.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults) {
                                object.tags = [];
                                object.steps = [];
                                object.examples = [];
                            }
                            if (options.defaults) {
                                object.location = null;
                                object.keyword = "";
                                object.name = "";
                                object.description = "";
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.tags && message.tags.length) {
                                object.tags = [];
                                for (var j = 0; j < message.tags.length; ++j)
                                    object.tags[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.toObject(message.tags[j], options);
                            }
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                object.keyword = message.keyword;
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            if (message.steps && message.steps.length) {
                                object.steps = [];
                                for (var j = 0; j < message.steps.length; ++j)
                                    object.steps[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Step.toObject(message.steps[j], options);
                            }
                            if (message.examples && message.examples.length) {
                                object.examples = [];
                                for (var j = 0; j < message.examples.length; ++j)
                                    object.examples[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.toObject(message.examples[j], options);
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this Scenario to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Scenario.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Scenario.Examples = (function() {

                            /**
                             * Properties of an Examples.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                             * @interface IExamples
                             * @property {io.cucumber.messages.ILocation|null} [location] Examples location
                             * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>|null} [tags] Examples tags
                             * @property {string|null} [keyword] Examples keyword
                             * @property {string|null} [name] Examples name
                             * @property {string|null} [description] Examples description
                             * @property {io.cucumber.messages.GherkinDocument.Feature.ITableRow|null} [tableHeader] Examples tableHeader
                             * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITableRow>|null} [tableBody] Examples tableBody
                             * @property {string|null} [id] Examples id
                             */

                            /**
                             * Constructs a new Examples.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario
                             * @classdesc Represents an Examples.
                             * @implements IExamples
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples=} [properties] Properties to set
                             */
                            function Examples(properties) {
                                this.tags = [];
                                this.tableBody = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Examples location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.location = null;

                            /**
                             * Examples tags.
                             * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITag>} tags
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.tags = $util.emptyArray;

                            /**
                             * Examples keyword.
                             * @member {string} keyword
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.keyword = "";

                            /**
                             * Examples name.
                             * @member {string} name
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.name = "";

                            /**
                             * Examples description.
                             * @member {string} description
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.description = "";

                            /**
                             * Examples tableHeader.
                             * @member {io.cucumber.messages.GherkinDocument.Feature.ITableRow|null|undefined} tableHeader
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.tableHeader = null;

                            /**
                             * Examples tableBody.
                             * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITableRow>} tableBody
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.tableBody = $util.emptyArray;

                            /**
                             * Examples id.
                             * @member {string} id
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             */
                            Examples.prototype.id = "";

                            /**
                             * Creates a new Examples instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} Examples instance
                             */
                            Examples.create = function create(properties) {
                                return new Examples(properties);
                            };

                            /**
                             * Encodes the specified Examples message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples} message Examples message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Examples.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.tags != null && message.tags.length)
                                    for (var i = 0; i < message.tags.length; ++i)
                                        $root.io.cucumber.messages.GherkinDocument.Feature.Tag.encode(message.tags[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.keyword);
                                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                                if (message.tableHeader != null && Object.hasOwnProperty.call(message, "tableHeader"))
                                    $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.encode(message.tableHeader, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                                if (message.tableBody != null && message.tableBody.length)
                                    for (var i = 0; i < message.tableBody.length; ++i)
                                        $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.encode(message.tableBody[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.id);
                                return writer;
                            };

                            /**
                             * Encodes the specified Examples message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.IExamples} message Examples message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Examples.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an Examples message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} Examples
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Examples.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        if (!(message.tags && message.tags.length))
                                            message.tags = [];
                                        message.tags.push($root.io.cucumber.messages.GherkinDocument.Feature.Tag.decode(reader, reader.uint32()));
                                        break;
                                    case 3:
                                        message.keyword = reader.string();
                                        break;
                                    case 4:
                                        message.name = reader.string();
                                        break;
                                    case 5:
                                        message.description = reader.string();
                                        break;
                                    case 6:
                                        message.tableHeader = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.decode(reader, reader.uint32());
                                        break;
                                    case 7:
                                        if (!(message.tableBody && message.tableBody.length))
                                            message.tableBody = [];
                                        message.tableBody.push($root.io.cucumber.messages.GherkinDocument.Feature.TableRow.decode(reader, reader.uint32()));
                                        break;
                                    case 8:
                                        message.id = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an Examples message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} Examples
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Examples.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an Examples message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Examples.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.tags != null && message.hasOwnProperty("tags")) {
                                    if (!Array.isArray(message.tags))
                                        return "tags: array expected";
                                    for (var i = 0; i < message.tags.length; ++i) {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.verify(message.tags[i]);
                                        if (error)
                                            return "tags." + error;
                                    }
                                }
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    if (!$util.isString(message.keyword))
                                        return "keyword: string expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                if (message.tableHeader != null && message.hasOwnProperty("tableHeader")) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.verify(message.tableHeader);
                                    if (error)
                                        return "tableHeader." + error;
                                }
                                if (message.tableBody != null && message.hasOwnProperty("tableBody")) {
                                    if (!Array.isArray(message.tableBody))
                                        return "tableBody: array expected";
                                    for (var i = 0; i < message.tableBody.length; ++i) {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.verify(message.tableBody[i]);
                                        if (error)
                                            return "tableBody." + error;
                                    }
                                }
                                if (message.id != null && message.hasOwnProperty("id"))
                                    if (!$util.isString(message.id))
                                        return "id: string expected";
                                return null;
                            };

                            /**
                             * Creates an Examples message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} Examples
                             */
                            Examples.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.tags) {
                                    if (!Array.isArray(object.tags))
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tags: array expected");
                                    message.tags = [];
                                    for (var i = 0; i < object.tags.length; ++i) {
                                        if (typeof object.tags[i] !== "object")
                                            throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tags: object expected");
                                        message.tags[i] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.fromObject(object.tags[i]);
                                    }
                                }
                                if (object.keyword != null)
                                    message.keyword = String(object.keyword);
                                if (object.name != null)
                                    message.name = String(object.name);
                                if (object.description != null)
                                    message.description = String(object.description);
                                if (object.tableHeader != null) {
                                    if (typeof object.tableHeader !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tableHeader: object expected");
                                    message.tableHeader = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.fromObject(object.tableHeader);
                                }
                                if (object.tableBody) {
                                    if (!Array.isArray(object.tableBody))
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tableBody: array expected");
                                    message.tableBody = [];
                                    for (var i = 0; i < object.tableBody.length; ++i) {
                                        if (typeof object.tableBody[i] !== "object")
                                            throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples.tableBody: object expected");
                                        message.tableBody[i] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.fromObject(object.tableBody[i]);
                                    }
                                }
                                if (object.id != null)
                                    message.id = String(object.id);
                                return message;
                            };

                            /**
                             * Creates a plain object from an Examples message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples} message Examples
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Examples.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults) {
                                    object.tags = [];
                                    object.tableBody = [];
                                }
                                if (options.defaults) {
                                    object.location = null;
                                    object.keyword = "";
                                    object.name = "";
                                    object.description = "";
                                    object.tableHeader = null;
                                    object.id = "";
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.tags && message.tags.length) {
                                    object.tags = [];
                                    for (var j = 0; j < message.tags.length; ++j)
                                        object.tags[j] = $root.io.cucumber.messages.GherkinDocument.Feature.Tag.toObject(message.tags[j], options);
                                }
                                if (message.keyword != null && message.hasOwnProperty("keyword"))
                                    object.keyword = message.keyword;
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                if (message.tableHeader != null && message.hasOwnProperty("tableHeader"))
                                    object.tableHeader = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.toObject(message.tableHeader, options);
                                if (message.tableBody && message.tableBody.length) {
                                    object.tableBody = [];
                                    for (var j = 0; j < message.tableBody.length; ++j)
                                        object.tableBody[j] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.toObject(message.tableBody[j], options);
                                }
                                if (message.id != null && message.hasOwnProperty("id"))
                                    object.id = message.id;
                                return object;
                            };

                            /**
                             * Converts this Examples to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Examples.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Examples;
                        })();

                        return Scenario;
                    })();

                    Feature.TableRow = (function() {

                        /**
                         * Properties of a TableRow.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface ITableRow
                         * @property {io.cucumber.messages.ILocation|null} [location] TableRow location
                         * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell>|null} [cells] TableRow cells
                         * @property {string|null} [id] TableRow id
                         */

                        /**
                         * Constructs a new TableRow.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc Represents a TableRow.
                         * @implements ITableRow
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITableRow=} [properties] Properties to set
                         */
                        function TableRow(properties) {
                            this.cells = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * TableRow location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @instance
                         */
                        TableRow.prototype.location = null;

                        /**
                         * TableRow cells.
                         * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell>} cells
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @instance
                         */
                        TableRow.prototype.cells = $util.emptyArray;

                        /**
                         * TableRow id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @instance
                         */
                        TableRow.prototype.id = "";

                        /**
                         * Creates a new TableRow instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITableRow=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow} TableRow instance
                         */
                        TableRow.create = function create(properties) {
                            return new TableRow(properties);
                        };

                        /**
                         * Encodes the specified TableRow message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.TableRow.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITableRow} message TableRow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TableRow.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.cells != null && message.cells.length)
                                for (var i = 0; i < message.cells.length; ++i)
                                    $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.encode(message.cells[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified TableRow message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.TableRow.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.ITableRow} message TableRow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        TableRow.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a TableRow message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow} TableRow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TableRow.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.TableRow();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    if (!(message.cells && message.cells.length))
                                        message.cells = [];
                                    message.cells.push($root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.decode(reader, reader.uint32()));
                                    break;
                                case 3:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a TableRow message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow} TableRow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        TableRow.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a TableRow message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        TableRow.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.cells != null && message.hasOwnProperty("cells")) {
                                if (!Array.isArray(message.cells))
                                    return "cells: array expected";
                                for (var i = 0; i < message.cells.length; ++i) {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.verify(message.cells[i]);
                                    if (error)
                                        return "cells." + error;
                                }
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a TableRow message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow} TableRow
                         */
                        TableRow.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.TableRow)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.TableRow();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.TableRow.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.cells) {
                                if (!Array.isArray(object.cells))
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.TableRow.cells: array expected");
                                message.cells = [];
                                for (var i = 0; i < object.cells.length; ++i) {
                                    if (typeof object.cells[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.TableRow.cells: object expected");
                                    message.cells[i] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.fromObject(object.cells[i]);
                                }
                            }
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a TableRow message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow} message TableRow
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        TableRow.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.cells = [];
                            if (options.defaults) {
                                object.location = null;
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.cells && message.cells.length) {
                                object.cells = [];
                                for (var j = 0; j < message.cells.length; ++j)
                                    object.cells[j] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.toObject(message.cells[j], options);
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this TableRow to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        TableRow.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        TableRow.TableCell = (function() {

                            /**
                             * Properties of a TableCell.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                             * @interface ITableCell
                             * @property {io.cucumber.messages.ILocation|null} [location] TableCell location
                             * @property {string|null} [value] TableCell value
                             */

                            /**
                             * Constructs a new TableCell.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow
                             * @classdesc Represents a TableCell.
                             * @implements ITableCell
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell=} [properties] Properties to set
                             */
                            function TableCell(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * TableCell location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @instance
                             */
                            TableCell.prototype.location = null;

                            /**
                             * TableCell value.
                             * @member {string} value
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @instance
                             */
                            TableCell.prototype.value = "";

                            /**
                             * Creates a new TableCell instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} TableCell instance
                             */
                            TableCell.create = function create(properties) {
                                return new TableCell(properties);
                            };

                            /**
                             * Encodes the specified TableCell message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell} message TableCell message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TableCell.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                                return writer;
                            };

                            /**
                             * Encodes the specified TableCell message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.ITableCell} message TableCell message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            TableCell.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a TableCell message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} TableCell
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TableCell.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.value = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a TableCell message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} TableCell
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            TableCell.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a TableCell message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            TableCell.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.value != null && message.hasOwnProperty("value"))
                                    if (!$util.isString(message.value))
                                        return "value: string expected";
                                return null;
                            };

                            /**
                             * Creates a TableCell message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} TableCell
                             */
                            TableCell.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.value != null)
                                    message.value = String(object.value);
                                return message;
                            };

                            /**
                             * Creates a plain object from a TableCell message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell} message TableCell
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            TableCell.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.location = null;
                                    object.value = "";
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.value != null && message.hasOwnProperty("value"))
                                    object.value = message.value;
                                return object;
                            };

                            /**
                             * Converts this TableCell to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            TableCell.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return TableCell;
                        })();

                        return TableRow;
                    })();

                    Feature.Step = (function() {

                        /**
                         * Properties of a Step.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @interface IStep
                         * @property {io.cucumber.messages.ILocation|null} [location] Step location
                         * @property {string|null} [keyword] Step keyword
                         * @property {string|null} [text] Step text
                         * @property {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString|null} [docString] Step docString
                         * @property {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable|null} [dataTable] Step dataTable
                         * @property {string|null} [id] Step id
                         */

                        /**
                         * Constructs a new Step.
                         * @memberof io.cucumber.messages.GherkinDocument.Feature
                         * @classdesc Represents a Step.
                         * @implements IStep
                         * @constructor
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IStep=} [properties] Properties to set
                         */
                        function Step(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Step location.
                         * @member {io.cucumber.messages.ILocation|null|undefined} location
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.location = null;

                        /**
                         * Step keyword.
                         * @member {string} keyword
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.keyword = "";

                        /**
                         * Step text.
                         * @member {string} text
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.text = "";

                        /**
                         * Step docString.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString|null|undefined} docString
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.docString = null;

                        /**
                         * Step dataTable.
                         * @member {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable|null|undefined} dataTable
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.dataTable = null;

                        /**
                         * Step id.
                         * @member {string} id
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Step.prototype.id = "";

                        // OneOf field names bound to virtual getters and setters
                        var $oneOfFields;

                        /**
                         * Step argument.
                         * @member {"docString"|"dataTable"|undefined} argument
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         */
                        Object.defineProperty(Step.prototype, "argument", {
                            get: $util.oneOfGetter($oneOfFields = ["docString", "dataTable"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Creates a new Step instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IStep=} [properties] Properties to set
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Step} Step instance
                         */
                        Step.create = function create(properties) {
                            return new Step(properties);
                        };

                        /**
                         * Encodes the specified Step message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IStep} message Step message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Step.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.keyword != null && Object.hasOwnProperty.call(message, "keyword"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.keyword);
                            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
                            if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.encode(message.docString, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.dataTable != null && Object.hasOwnProperty.call(message, "dataTable"))
                                $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.encode(message.dataTable, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified Step message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.IStep} message Step message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Step.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Step message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Step} Step
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Step.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.keyword = reader.string();
                                    break;
                                case 3:
                                    message.text = reader.string();
                                    break;
                                case 4:
                                    message.docString = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.decode(reader, reader.uint32());
                                    break;
                                case 5:
                                    message.dataTable = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.decode(reader, reader.uint32());
                                    break;
                                case 6:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Step message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Step} Step
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Step.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Step message.
                         * @function verify
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Step.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            var properties = {};
                            if (message.location != null && message.hasOwnProperty("location")) {
                                var error = $root.io.cucumber.messages.Location.verify(message.location);
                                if (error)
                                    return "location." + error;
                            }
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                if (!$util.isString(message.keyword))
                                    return "keyword: string expected";
                            if (message.text != null && message.hasOwnProperty("text"))
                                if (!$util.isString(message.text))
                                    return "text: string expected";
                            if (message.docString != null && message.hasOwnProperty("docString")) {
                                properties.argument = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.verify(message.docString);
                                    if (error)
                                        return "docString." + error;
                                }
                            }
                            if (message.dataTable != null && message.hasOwnProperty("dataTable")) {
                                if (properties.argument === 1)
                                    return "argument: multiple values";
                                properties.argument = 1;
                                {
                                    var error = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.verify(message.dataTable);
                                    if (error)
                                        return "dataTable." + error;
                                }
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a Step message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.GherkinDocument.Feature.Step} Step
                         */
                        Step.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Step)
                                return object;
                            var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step();
                            if (object.location != null) {
                                if (typeof object.location !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.location: object expected");
                                message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                            }
                            if (object.keyword != null)
                                message.keyword = String(object.keyword);
                            if (object.text != null)
                                message.text = String(object.text);
                            if (object.docString != null) {
                                if (typeof object.docString !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.docString: object expected");
                                message.docString = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.fromObject(object.docString);
                            }
                            if (object.dataTable != null) {
                                if (typeof object.dataTable !== "object")
                                    throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.dataTable: object expected");
                                message.dataTable = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.fromObject(object.dataTable);
                            }
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Step message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @static
                         * @param {io.cucumber.messages.GherkinDocument.Feature.Step} message Step
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Step.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.location = null;
                                object.keyword = "";
                                object.text = "";
                                object.id = "";
                            }
                            if (message.location != null && message.hasOwnProperty("location"))
                                object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                            if (message.keyword != null && message.hasOwnProperty("keyword"))
                                object.keyword = message.keyword;
                            if (message.text != null && message.hasOwnProperty("text"))
                                object.text = message.text;
                            if (message.docString != null && message.hasOwnProperty("docString")) {
                                object.docString = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString.toObject(message.docString, options);
                                if (options.oneofs)
                                    object.argument = "docString";
                            }
                            if (message.dataTable != null && message.hasOwnProperty("dataTable")) {
                                object.dataTable = $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.toObject(message.dataTable, options);
                                if (options.oneofs)
                                    object.argument = "dataTable";
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this Step to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Step.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Step.DataTable = (function() {

                            /**
                             * Properties of a DataTable.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                             * @interface IDataTable
                             * @property {io.cucumber.messages.ILocation|null} [location] DataTable location
                             * @property {Array.<io.cucumber.messages.GherkinDocument.Feature.ITableRow>|null} [rows] DataTable rows
                             */

                            /**
                             * Constructs a new DataTable.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                             * @classdesc Represents a DataTable.
                             * @implements IDataTable
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable=} [properties] Properties to set
                             */
                            function DataTable(properties) {
                                this.rows = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * DataTable location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @instance
                             */
                            DataTable.prototype.location = null;

                            /**
                             * DataTable rows.
                             * @member {Array.<io.cucumber.messages.GherkinDocument.Feature.ITableRow>} rows
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @instance
                             */
                            DataTable.prototype.rows = $util.emptyArray;

                            /**
                             * Creates a new DataTable instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} DataTable instance
                             */
                            DataTable.create = function create(properties) {
                                return new DataTable(properties);
                            };

                            /**
                             * Encodes the specified DataTable message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable} message DataTable message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            DataTable.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.rows != null && message.rows.length)
                                    for (var i = 0; i < message.rows.length; ++i)
                                        $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified DataTable message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDataTable} message DataTable message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            DataTable.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a DataTable message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} DataTable
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            DataTable.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        if (!(message.rows && message.rows.length))
                                            message.rows = [];
                                        message.rows.push($root.io.cucumber.messages.GherkinDocument.Feature.TableRow.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a DataTable message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} DataTable
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            DataTable.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a DataTable message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            DataTable.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.rows != null && message.hasOwnProperty("rows")) {
                                    if (!Array.isArray(message.rows))
                                        return "rows: array expected";
                                    for (var i = 0; i < message.rows.length; ++i) {
                                        var error = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.verify(message.rows[i]);
                                        if (error)
                                            return "rows." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates a DataTable message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} DataTable
                             */
                            DataTable.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step.DataTable();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.rows) {
                                    if (!Array.isArray(object.rows))
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.rows: array expected");
                                    message.rows = [];
                                    for (var i = 0; i < object.rows.length; ++i) {
                                        if (typeof object.rows[i] !== "object")
                                            throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.DataTable.rows: object expected");
                                        message.rows[i] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.fromObject(object.rows[i]);
                                    }
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a DataTable message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.DataTable} message DataTable
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            DataTable.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults)
                                    object.rows = [];
                                if (options.defaults)
                                    object.location = null;
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.rows && message.rows.length) {
                                    object.rows = [];
                                    for (var j = 0; j < message.rows.length; ++j)
                                        object.rows[j] = $root.io.cucumber.messages.GherkinDocument.Feature.TableRow.toObject(message.rows[j], options);
                                }
                                return object;
                            };

                            /**
                             * Converts this DataTable to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DataTable
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            DataTable.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return DataTable;
                        })();

                        Step.DocString = (function() {

                            /**
                             * Properties of a DocString.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                             * @interface IDocString
                             * @property {io.cucumber.messages.ILocation|null} [location] DocString location
                             * @property {string|null} [mediaType] DocString mediaType
                             * @property {string|null} [content] DocString content
                             * @property {string|null} [delimiter] DocString delimiter
                             */

                            /**
                             * Constructs a new DocString.
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step
                             * @classdesc Represents a DocString.
                             * @implements IDocString
                             * @constructor
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString=} [properties] Properties to set
                             */
                            function DocString(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * DocString location.
                             * @member {io.cucumber.messages.ILocation|null|undefined} location
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             */
                            DocString.prototype.location = null;

                            /**
                             * DocString mediaType.
                             * @member {string} mediaType
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             */
                            DocString.prototype.mediaType = "";

                            /**
                             * DocString content.
                             * @member {string} content
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             */
                            DocString.prototype.content = "";

                            /**
                             * DocString delimiter.
                             * @member {string} delimiter
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             */
                            DocString.prototype.delimiter = "";

                            /**
                             * Creates a new DocString instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString=} [properties] Properties to set
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} DocString instance
                             */
                            DocString.create = function create(properties) {
                                return new DocString(properties);
                            };

                            /**
                             * Encodes the specified DocString message. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.DocString.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString} message DocString message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            DocString.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                                    $root.io.cucumber.messages.Location.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.mediaType);
                                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
                                if (message.delimiter != null && Object.hasOwnProperty.call(message, "delimiter"))
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.delimiter);
                                return writer;
                            };

                            /**
                             * Encodes the specified DocString message, length delimited. Does not implicitly {@link io.cucumber.messages.GherkinDocument.Feature.Step.DocString.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.IDocString} message DocString message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            DocString.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a DocString message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} DocString
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            DocString.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.location = $root.io.cucumber.messages.Location.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.mediaType = reader.string();
                                        break;
                                    case 3:
                                        message.content = reader.string();
                                        break;
                                    case 4:
                                        message.delimiter = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a DocString message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} DocString
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            DocString.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a DocString message.
                             * @function verify
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            DocString.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.location != null && message.hasOwnProperty("location")) {
                                    var error = $root.io.cucumber.messages.Location.verify(message.location);
                                    if (error)
                                        return "location." + error;
                                }
                                if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                                    if (!$util.isString(message.mediaType))
                                        return "mediaType: string expected";
                                if (message.content != null && message.hasOwnProperty("content"))
                                    if (!$util.isString(message.content))
                                        return "content: string expected";
                                if (message.delimiter != null && message.hasOwnProperty("delimiter"))
                                    if (!$util.isString(message.delimiter))
                                        return "delimiter: string expected";
                                return null;
                            };

                            /**
                             * Creates a DocString message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} DocString
                             */
                            DocString.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString)
                                    return object;
                                var message = new $root.io.cucumber.messages.GherkinDocument.Feature.Step.DocString();
                                if (object.location != null) {
                                    if (typeof object.location !== "object")
                                        throw TypeError(".io.cucumber.messages.GherkinDocument.Feature.Step.DocString.location: object expected");
                                    message.location = $root.io.cucumber.messages.Location.fromObject(object.location);
                                }
                                if (object.mediaType != null)
                                    message.mediaType = String(object.mediaType);
                                if (object.content != null)
                                    message.content = String(object.content);
                                if (object.delimiter != null)
                                    message.delimiter = String(object.delimiter);
                                return message;
                            };

                            /**
                             * Creates a plain object from a DocString message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @static
                             * @param {io.cucumber.messages.GherkinDocument.Feature.Step.DocString} message DocString
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            DocString.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.location = null;
                                    object.mediaType = "";
                                    object.content = "";
                                    object.delimiter = "";
                                }
                                if (message.location != null && message.hasOwnProperty("location"))
                                    object.location = $root.io.cucumber.messages.Location.toObject(message.location, options);
                                if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                                    object.mediaType = message.mediaType;
                                if (message.content != null && message.hasOwnProperty("content"))
                                    object.content = message.content;
                                if (message.delimiter != null && message.hasOwnProperty("delimiter"))
                                    object.delimiter = message.delimiter;
                                return object;
                            };

                            /**
                             * Converts this DocString to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.GherkinDocument.Feature.Step.DocString
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            DocString.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return DocString;
                        })();

                        return Step;
                    })();

                    return Feature;
                })();

                return GherkinDocument;
            })();

            messages.Attachment = (function() {

                /**
                 * Properties of an Attachment.
                 * @memberof io.cucumber.messages
                 * @interface IAttachment
                 * @property {io.cucumber.messages.ISourceReference|null} [source] Attachment source
                 * @property {string|null} [testStepId] Attachment testStepId
                 * @property {string|null} [testCaseStartedId] Attachment testCaseStartedId
                 * @property {string|null} [body] The body of the attachment. If `content_encoding` is `IDENTITY`, the attachment
                 * is simply the string. If it's `BASE64`, the string should be Base64 decoded to
                 * obtain the attachment.
                 * @property {string|null} [mediaType] The media type of the data. This can be any valid
                 * [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
                 * as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
                 * and `text/x.cucumber.stacktrace+plain`
                 * @property {io.cucumber.messages.Attachment.ContentEncoding|null} [contentEncoding] Whether to interpret `body` "as-is" (IDENTITY) or if it needs to be Base64-decoded (BASE64).
                 * 
                 * Content encoding is *not* determined by the media type, but rather by the type
                 * of the object being attached:
                 * 
                 * - string => IDENTITY
                 * - byte array => BASE64
                 * - stream => BASE64
                 * @property {string|null} [fileName] Suggested file name of the attachment. (Provided by the user as an argument to `attach`)
                 * @property {string|null} [url] A URL where the attachment can be retrieved. This field should not be set by Cucumber.
                 * It should be set by a program that reads a message stream and does the following for
                 * each Attachment message:
                 * 
                 * - Writes the body (after base64 decoding if necessary) to a new file.
                 * - Sets `body` and `content_encoding` to `null`
                 * - Writes out the new attachment message
                 * 
                 * This will result in a smaller message stream, which can improve performance and
                 * reduce bandwidth of message consumers. It also makes it easier to process and download attachments
                 * separately from reports.
                 */

                /**
                 * Constructs a new Attachment.
                 * @memberof io.cucumber.messages
                 * @classdesc An attachment represents any kind of data associated with a line in a
                 * [Source](#io.cucumber.messages.Source) file. It can be used for:
                 * 
                 * * Syntax errors during parse time
                 * * Screenshots captured and attached during execution
                 * * Logs captured and attached during execution
                 * 
                 * It is not to be used for runtime errors raised/thrown during execution. This
                 * is captured in `TestResult`.
                 * @implements IAttachment
                 * @constructor
                 * @param {io.cucumber.messages.IAttachment=} [properties] Properties to set
                 */
                function Attachment(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Attachment source.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} source
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.source = null;

                /**
                 * Attachment testStepId.
                 * @member {string} testStepId
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.testStepId = "";

                /**
                 * Attachment testCaseStartedId.
                 * @member {string} testCaseStartedId
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.testCaseStartedId = "";

                /**
                 * The body of the attachment. If `content_encoding` is `IDENTITY`, the attachment
                 * is simply the string. If it's `BASE64`, the string should be Base64 decoded to
                 * obtain the attachment.
                 * @member {string} body
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.body = "";

                /**
                 * The media type of the data. This can be any valid
                 * [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
                 * as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
                 * and `text/x.cucumber.stacktrace+plain`
                 * @member {string} mediaType
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.mediaType = "";

                /**
                 * Whether to interpret `body` "as-is" (IDENTITY) or if it needs to be Base64-decoded (BASE64).
                 * 
                 * Content encoding is *not* determined by the media type, but rather by the type
                 * of the object being attached:
                 * 
                 * - string => IDENTITY
                 * - byte array => BASE64
                 * - stream => BASE64
                 * @member {io.cucumber.messages.Attachment.ContentEncoding} contentEncoding
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.contentEncoding = 0;

                /**
                 * Suggested file name of the attachment. (Provided by the user as an argument to `attach`)
                 * @member {string} fileName
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.fileName = "";

                /**
                 * A URL where the attachment can be retrieved. This field should not be set by Cucumber.
                 * It should be set by a program that reads a message stream and does the following for
                 * each Attachment message:
                 * 
                 * - Writes the body (after base64 decoding if necessary) to a new file.
                 * - Sets `body` and `content_encoding` to `null`
                 * - Writes out the new attachment message
                 * 
                 * This will result in a smaller message stream, which can improve performance and
                 * reduce bandwidth of message consumers. It also makes it easier to process and download attachments
                 * separately from reports.
                 * @member {string} url
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 */
                Attachment.prototype.url = "";

                /**
                 * Creates a new Attachment instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {io.cucumber.messages.IAttachment=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Attachment} Attachment instance
                 */
                Attachment.create = function create(properties) {
                    return new Attachment(properties);
                };

                /**
                 * Encodes the specified Attachment message. Does not implicitly {@link io.cucumber.messages.Attachment.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {io.cucumber.messages.IAttachment} message Attachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                        $root.io.cucumber.messages.SourceReference.encode(message.source, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.testStepId != null && Object.hasOwnProperty.call(message, "testStepId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.testStepId);
                    if (message.testCaseStartedId != null && Object.hasOwnProperty.call(message, "testCaseStartedId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testCaseStartedId);
                    if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.body);
                    if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.mediaType);
                    if (message.contentEncoding != null && Object.hasOwnProperty.call(message, "contentEncoding"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.contentEncoding);
                    if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.url);
                    return writer;
                };

                /**
                 * Encodes the specified Attachment message, length delimited. Does not implicitly {@link io.cucumber.messages.Attachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {io.cucumber.messages.IAttachment} message Attachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Attachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Attachment} Attachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Attachment();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.source = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.testStepId = reader.string();
                            break;
                        case 3:
                            message.testCaseStartedId = reader.string();
                            break;
                        case 4:
                            message.body = reader.string();
                            break;
                        case 5:
                            message.mediaType = reader.string();
                            break;
                        case 6:
                            message.contentEncoding = reader.int32();
                            break;
                        case 7:
                            message.fileName = reader.string();
                            break;
                        case 8:
                            message.url = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Attachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Attachment} Attachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Attachment message.
                 * @function verify
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Attachment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.source != null && message.hasOwnProperty("source")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.source);
                        if (error)
                            return "source." + error;
                    }
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        if (!$util.isString(message.testStepId))
                            return "testStepId: string expected";
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        if (!$util.isString(message.testCaseStartedId))
                            return "testCaseStartedId: string expected";
                    if (message.body != null && message.hasOwnProperty("body"))
                        if (!$util.isString(message.body))
                            return "body: string expected";
                    if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                        if (!$util.isString(message.mediaType))
                            return "mediaType: string expected";
                    if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                        switch (message.contentEncoding) {
                        default:
                            return "contentEncoding: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.fileName != null && message.hasOwnProperty("fileName"))
                        if (!$util.isString(message.fileName))
                            return "fileName: string expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    return null;
                };

                /**
                 * Creates an Attachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Attachment} Attachment
                 */
                Attachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Attachment)
                        return object;
                    var message = new $root.io.cucumber.messages.Attachment();
                    if (object.source != null) {
                        if (typeof object.source !== "object")
                            throw TypeError(".io.cucumber.messages.Attachment.source: object expected");
                        message.source = $root.io.cucumber.messages.SourceReference.fromObject(object.source);
                    }
                    if (object.testStepId != null)
                        message.testStepId = String(object.testStepId);
                    if (object.testCaseStartedId != null)
                        message.testCaseStartedId = String(object.testCaseStartedId);
                    if (object.body != null)
                        message.body = String(object.body);
                    if (object.mediaType != null)
                        message.mediaType = String(object.mediaType);
                    switch (object.contentEncoding) {
                    case "IDENTITY":
                    case 0:
                        message.contentEncoding = 0;
                        break;
                    case "BASE64":
                    case 1:
                        message.contentEncoding = 1;
                        break;
                    }
                    if (object.fileName != null)
                        message.fileName = String(object.fileName);
                    if (object.url != null)
                        message.url = String(object.url);
                    return message;
                };

                /**
                 * Creates a plain object from an Attachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Attachment
                 * @static
                 * @param {io.cucumber.messages.Attachment} message Attachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Attachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.source = null;
                        object.testStepId = "";
                        object.testCaseStartedId = "";
                        object.body = "";
                        object.mediaType = "";
                        object.contentEncoding = options.enums === String ? "IDENTITY" : 0;
                        object.fileName = "";
                        object.url = "";
                    }
                    if (message.source != null && message.hasOwnProperty("source"))
                        object.source = $root.io.cucumber.messages.SourceReference.toObject(message.source, options);
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        object.testStepId = message.testStepId;
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        object.testCaseStartedId = message.testCaseStartedId;
                    if (message.body != null && message.hasOwnProperty("body"))
                        object.body = message.body;
                    if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                        object.mediaType = message.mediaType;
                    if (message.contentEncoding != null && message.hasOwnProperty("contentEncoding"))
                        object.contentEncoding = options.enums === String ? $root.io.cucumber.messages.Attachment.ContentEncoding[message.contentEncoding] : message.contentEncoding;
                    if (message.fileName != null && message.hasOwnProperty("fileName"))
                        object.fileName = message.fileName;
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    return object;
                };

                /**
                 * Converts this Attachment to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Attachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Attachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * ContentEncoding enum.
                 * @name io.cucumber.messages.Attachment.ContentEncoding
                 * @enum {number}
                 * @property {number} IDENTITY=0 IDENTITY value
                 * @property {number} BASE64=1 BASE64 value
                 */
                Attachment.ContentEncoding = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "IDENTITY"] = 0;
                    values[valuesById[1] = "BASE64"] = 1;
                    return values;
                })();

                return Attachment;
            })();

            messages.Pickle = (function() {

                /**
                 * Properties of a Pickle.
                 * @memberof io.cucumber.messages
                 * @interface IPickle
                 * @property {string|null} [id] A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
                 * from the source data and the `locations` of the pickle.
                 * This ID will change if source the file is modified.
                 * @property {string|null} [uri] Pickle uri
                 * @property {string|null} [name] Pickle name
                 * @property {string|null} [language] Pickle language
                 * @property {Array.<io.cucumber.messages.Pickle.IPickleStep>|null} [steps] Pickle steps
                 * @property {Array.<io.cucumber.messages.Pickle.IPickleTag>|null} [tags] One or more tags. If this pickle is constructed from a Gherkin document,
                 * It includes inherited tags from the `Feature` as well.
                 * @property {Array.<string>|null} [astNodeIds] Points to the AST node locations of the pickle. The last one represents the unique
                 * id of the pickle. A pickle constructed from `Examples` will have the first
                 * id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.
                 */

                /**
                 * Constructs a new Pickle.
                 * @memberof io.cucumber.messages
                 * @classdesc A `Pickle` represents a template for a `TestCase`. It is typically derived
                 * from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
                 * In the future a `Pickle` may be derived from other formats such as Markdown or
                 * Excel files.
                 * 
                 * By making `Pickle` the main data structure Cucumber uses for execution, the
                 * implementation of Cucumber itself becomes simpler, as it doesn't have to deal
                 * with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).
                 * 
                 * Each `PickleStep` of a `Pickle` is matched with a `StepDefinition` to create a `TestCase`
                 * @implements IPickle
                 * @constructor
                 * @param {io.cucumber.messages.IPickle=} [properties] Properties to set
                 */
                function Pickle(properties) {
                    this.steps = [];
                    this.tags = [];
                    this.astNodeIds = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
                 * from the source data and the `locations` of the pickle.
                 * This ID will change if source the file is modified.
                 * @member {string} id
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.id = "";

                /**
                 * Pickle uri.
                 * @member {string} uri
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.uri = "";

                /**
                 * Pickle name.
                 * @member {string} name
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.name = "";

                /**
                 * Pickle language.
                 * @member {string} language
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.language = "";

                /**
                 * Pickle steps.
                 * @member {Array.<io.cucumber.messages.Pickle.IPickleStep>} steps
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.steps = $util.emptyArray;

                /**
                 * One or more tags. If this pickle is constructed from a Gherkin document,
                 * It includes inherited tags from the `Feature` as well.
                 * @member {Array.<io.cucumber.messages.Pickle.IPickleTag>} tags
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.tags = $util.emptyArray;

                /**
                 * Points to the AST node locations of the pickle. The last one represents the unique
                 * id of the pickle. A pickle constructed from `Examples` will have the first
                 * id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.
                 * @member {Array.<string>} astNodeIds
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 */
                Pickle.prototype.astNodeIds = $util.emptyArray;

                /**
                 * Creates a new Pickle instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {io.cucumber.messages.IPickle=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Pickle} Pickle instance
                 */
                Pickle.create = function create(properties) {
                    return new Pickle(properties);
                };

                /**
                 * Encodes the specified Pickle message. Does not implicitly {@link io.cucumber.messages.Pickle.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {io.cucumber.messages.IPickle} message Pickle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pickle.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.language);
                    if (message.steps != null && message.steps.length)
                        for (var i = 0; i < message.steps.length; ++i)
                            $root.io.cucumber.messages.Pickle.PickleStep.encode(message.steps[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.tags != null && message.tags.length)
                        for (var i = 0; i < message.tags.length; ++i)
                            $root.io.cucumber.messages.Pickle.PickleTag.encode(message.tags[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.astNodeIds != null && message.astNodeIds.length)
                        for (var i = 0; i < message.astNodeIds.length; ++i)
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.astNodeIds[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Pickle message, length delimited. Does not implicitly {@link io.cucumber.messages.Pickle.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {io.cucumber.messages.IPickle} message Pickle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pickle.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Pickle message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Pickle} Pickle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pickle.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Pickle();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.uri = reader.string();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.language = reader.string();
                            break;
                        case 5:
                            if (!(message.steps && message.steps.length))
                                message.steps = [];
                            message.steps.push($root.io.cucumber.messages.Pickle.PickleStep.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push($root.io.cucumber.messages.Pickle.PickleTag.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.astNodeIds && message.astNodeIds.length))
                                message.astNodeIds = [];
                            message.astNodeIds.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Pickle message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Pickle} Pickle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pickle.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Pickle message.
                 * @function verify
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pickle.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        if (!$util.isString(message.uri))
                            return "uri: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.language != null && message.hasOwnProperty("language"))
                        if (!$util.isString(message.language))
                            return "language: string expected";
                    if (message.steps != null && message.hasOwnProperty("steps")) {
                        if (!Array.isArray(message.steps))
                            return "steps: array expected";
                        for (var i = 0; i < message.steps.length; ++i) {
                            var error = $root.io.cucumber.messages.Pickle.PickleStep.verify(message.steps[i]);
                            if (error)
                                return "steps." + error;
                        }
                    }
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (var i = 0; i < message.tags.length; ++i) {
                            var error = $root.io.cucumber.messages.Pickle.PickleTag.verify(message.tags[i]);
                            if (error)
                                return "tags." + error;
                        }
                    }
                    if (message.astNodeIds != null && message.hasOwnProperty("astNodeIds")) {
                        if (!Array.isArray(message.astNodeIds))
                            return "astNodeIds: array expected";
                        for (var i = 0; i < message.astNodeIds.length; ++i)
                            if (!$util.isString(message.astNodeIds[i]))
                                return "astNodeIds: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Pickle message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Pickle} Pickle
                 */
                Pickle.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Pickle)
                        return object;
                    var message = new $root.io.cucumber.messages.Pickle();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.uri != null)
                        message.uri = String(object.uri);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.language != null)
                        message.language = String(object.language);
                    if (object.steps) {
                        if (!Array.isArray(object.steps))
                            throw TypeError(".io.cucumber.messages.Pickle.steps: array expected");
                        message.steps = [];
                        for (var i = 0; i < object.steps.length; ++i) {
                            if (typeof object.steps[i] !== "object")
                                throw TypeError(".io.cucumber.messages.Pickle.steps: object expected");
                            message.steps[i] = $root.io.cucumber.messages.Pickle.PickleStep.fromObject(object.steps[i]);
                        }
                    }
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".io.cucumber.messages.Pickle.tags: array expected");
                        message.tags = [];
                        for (var i = 0; i < object.tags.length; ++i) {
                            if (typeof object.tags[i] !== "object")
                                throw TypeError(".io.cucumber.messages.Pickle.tags: object expected");
                            message.tags[i] = $root.io.cucumber.messages.Pickle.PickleTag.fromObject(object.tags[i]);
                        }
                    }
                    if (object.astNodeIds) {
                        if (!Array.isArray(object.astNodeIds))
                            throw TypeError(".io.cucumber.messages.Pickle.astNodeIds: array expected");
                        message.astNodeIds = [];
                        for (var i = 0; i < object.astNodeIds.length; ++i)
                            message.astNodeIds[i] = String(object.astNodeIds[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Pickle message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Pickle
                 * @static
                 * @param {io.cucumber.messages.Pickle} message Pickle
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pickle.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.steps = [];
                        object.tags = [];
                        object.astNodeIds = [];
                    }
                    if (options.defaults) {
                        object.id = "";
                        object.uri = "";
                        object.name = "";
                        object.language = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.uri != null && message.hasOwnProperty("uri"))
                        object.uri = message.uri;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.language != null && message.hasOwnProperty("language"))
                        object.language = message.language;
                    if (message.steps && message.steps.length) {
                        object.steps = [];
                        for (var j = 0; j < message.steps.length; ++j)
                            object.steps[j] = $root.io.cucumber.messages.Pickle.PickleStep.toObject(message.steps[j], options);
                    }
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (var j = 0; j < message.tags.length; ++j)
                            object.tags[j] = $root.io.cucumber.messages.Pickle.PickleTag.toObject(message.tags[j], options);
                    }
                    if (message.astNodeIds && message.astNodeIds.length) {
                        object.astNodeIds = [];
                        for (var j = 0; j < message.astNodeIds.length; ++j)
                            object.astNodeIds[j] = message.astNodeIds[j];
                    }
                    return object;
                };

                /**
                 * Converts this Pickle to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Pickle
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pickle.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Pickle.PickleTag = (function() {

                    /**
                     * Properties of a PickleTag.
                     * @memberof io.cucumber.messages.Pickle
                     * @interface IPickleTag
                     * @property {string|null} [name] PickleTag name
                     * @property {string|null} [astNodeId] PickleTag astNodeId
                     */

                    /**
                     * Constructs a new PickleTag.
                     * @memberof io.cucumber.messages.Pickle
                     * @classdesc A tag
                     * @implements IPickleTag
                     * @constructor
                     * @param {io.cucumber.messages.Pickle.IPickleTag=} [properties] Properties to set
                     */
                    function PickleTag(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PickleTag name.
                     * @member {string} name
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @instance
                     */
                    PickleTag.prototype.name = "";

                    /**
                     * PickleTag astNodeId.
                     * @member {string} astNodeId
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @instance
                     */
                    PickleTag.prototype.astNodeId = "";

                    /**
                     * Creates a new PickleTag instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleTag=} [properties] Properties to set
                     * @returns {io.cucumber.messages.Pickle.PickleTag} PickleTag instance
                     */
                    PickleTag.create = function create(properties) {
                        return new PickleTag(properties);
                    };

                    /**
                     * Encodes the specified PickleTag message. Does not implicitly {@link io.cucumber.messages.Pickle.PickleTag.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleTag} message PickleTag message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleTag.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.astNodeId != null && Object.hasOwnProperty.call(message, "astNodeId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.astNodeId);
                        return writer;
                    };

                    /**
                     * Encodes the specified PickleTag message, length delimited. Does not implicitly {@link io.cucumber.messages.Pickle.PickleTag.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleTag} message PickleTag message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleTag.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PickleTag message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.Pickle.PickleTag} PickleTag
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleTag.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Pickle.PickleTag();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.astNodeId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PickleTag message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.Pickle.PickleTag} PickleTag
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleTag.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PickleTag message.
                     * @function verify
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PickleTag.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.astNodeId != null && message.hasOwnProperty("astNodeId"))
                            if (!$util.isString(message.astNodeId))
                                return "astNodeId: string expected";
                        return null;
                    };

                    /**
                     * Creates a PickleTag message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.Pickle.PickleTag} PickleTag
                     */
                    PickleTag.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.Pickle.PickleTag)
                            return object;
                        var message = new $root.io.cucumber.messages.Pickle.PickleTag();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.astNodeId != null)
                            message.astNodeId = String(object.astNodeId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PickleTag message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @static
                     * @param {io.cucumber.messages.Pickle.PickleTag} message PickleTag
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PickleTag.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.astNodeId = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.astNodeId != null && message.hasOwnProperty("astNodeId"))
                            object.astNodeId = message.astNodeId;
                        return object;
                    };

                    /**
                     * Converts this PickleTag to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.Pickle.PickleTag
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PickleTag.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PickleTag;
                })();

                Pickle.PickleStep = (function() {

                    /**
                     * Properties of a PickleStep.
                     * @memberof io.cucumber.messages.Pickle
                     * @interface IPickleStep
                     * @property {string|null} [text] PickleStep text
                     * @property {io.cucumber.messages.IPickleStepArgument|null} [argument] PickleStep argument
                     * @property {string|null} [id] PickleStep id
                     * @property {Array.<string>|null} [astNodeIds] PickleStep astNodeIds
                     */

                    /**
                     * Constructs a new PickleStep.
                     * @memberof io.cucumber.messages.Pickle
                     * @classdesc An executable step
                     * @implements IPickleStep
                     * @constructor
                     * @param {io.cucumber.messages.Pickle.IPickleStep=} [properties] Properties to set
                     */
                    function PickleStep(properties) {
                        this.astNodeIds = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PickleStep text.
                     * @member {string} text
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     */
                    PickleStep.prototype.text = "";

                    /**
                     * PickleStep argument.
                     * @member {io.cucumber.messages.IPickleStepArgument|null|undefined} argument
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     */
                    PickleStep.prototype.argument = null;

                    /**
                     * PickleStep id.
                     * @member {string} id
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     */
                    PickleStep.prototype.id = "";

                    /**
                     * PickleStep astNodeIds.
                     * @member {Array.<string>} astNodeIds
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     */
                    PickleStep.prototype.astNodeIds = $util.emptyArray;

                    /**
                     * Creates a new PickleStep instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleStep=} [properties] Properties to set
                     * @returns {io.cucumber.messages.Pickle.PickleStep} PickleStep instance
                     */
                    PickleStep.create = function create(properties) {
                        return new PickleStep(properties);
                    };

                    /**
                     * Encodes the specified PickleStep message. Does not implicitly {@link io.cucumber.messages.Pickle.PickleStep.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleStep} message PickleStep message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleStep.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                        if (message.argument != null && Object.hasOwnProperty.call(message, "argument"))
                            $root.io.cucumber.messages.PickleStepArgument.encode(message.argument, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                        if (message.astNodeIds != null && message.astNodeIds.length)
                            for (var i = 0; i < message.astNodeIds.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.astNodeIds[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified PickleStep message, length delimited. Does not implicitly {@link io.cucumber.messages.Pickle.PickleStep.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {io.cucumber.messages.Pickle.IPickleStep} message PickleStep message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleStep.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PickleStep message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.Pickle.PickleStep} PickleStep
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleStep.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Pickle.PickleStep();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.text = reader.string();
                                break;
                            case 2:
                                message.argument = $root.io.cucumber.messages.PickleStepArgument.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.id = reader.string();
                                break;
                            case 4:
                                if (!(message.astNodeIds && message.astNodeIds.length))
                                    message.astNodeIds = [];
                                message.astNodeIds.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PickleStep message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.Pickle.PickleStep} PickleStep
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleStep.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PickleStep message.
                     * @function verify
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PickleStep.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        if (message.argument != null && message.hasOwnProperty("argument")) {
                            var error = $root.io.cucumber.messages.PickleStepArgument.verify(message.argument);
                            if (error)
                                return "argument." + error;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.astNodeIds != null && message.hasOwnProperty("astNodeIds")) {
                            if (!Array.isArray(message.astNodeIds))
                                return "astNodeIds: array expected";
                            for (var i = 0; i < message.astNodeIds.length; ++i)
                                if (!$util.isString(message.astNodeIds[i]))
                                    return "astNodeIds: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a PickleStep message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.Pickle.PickleStep} PickleStep
                     */
                    PickleStep.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.Pickle.PickleStep)
                            return object;
                        var message = new $root.io.cucumber.messages.Pickle.PickleStep();
                        if (object.text != null)
                            message.text = String(object.text);
                        if (object.argument != null) {
                            if (typeof object.argument !== "object")
                                throw TypeError(".io.cucumber.messages.Pickle.PickleStep.argument: object expected");
                            message.argument = $root.io.cucumber.messages.PickleStepArgument.fromObject(object.argument);
                        }
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.astNodeIds) {
                            if (!Array.isArray(object.astNodeIds))
                                throw TypeError(".io.cucumber.messages.Pickle.PickleStep.astNodeIds: array expected");
                            message.astNodeIds = [];
                            for (var i = 0; i < object.astNodeIds.length; ++i)
                                message.astNodeIds[i] = String(object.astNodeIds[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a PickleStep message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @static
                     * @param {io.cucumber.messages.Pickle.PickleStep} message PickleStep
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PickleStep.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.astNodeIds = [];
                        if (options.defaults) {
                            object.text = "";
                            object.argument = null;
                            object.id = "";
                        }
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        if (message.argument != null && message.hasOwnProperty("argument"))
                            object.argument = $root.io.cucumber.messages.PickleStepArgument.toObject(message.argument, options);
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.astNodeIds && message.astNodeIds.length) {
                            object.astNodeIds = [];
                            for (var j = 0; j < message.astNodeIds.length; ++j)
                                object.astNodeIds[j] = message.astNodeIds[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this PickleStep to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.Pickle.PickleStep
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PickleStep.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PickleStep;
                })();

                return Pickle;
            })();

            messages.PickleStepArgument = (function() {

                /**
                 * Properties of a PickleStepArgument.
                 * @memberof io.cucumber.messages
                 * @interface IPickleStepArgument
                 * @property {io.cucumber.messages.PickleStepArgument.IPickleDocString|null} [docString] PickleStepArgument docString
                 * @property {io.cucumber.messages.PickleStepArgument.IPickleTable|null} [dataTable] PickleStepArgument dataTable
                 */

                /**
                 * Constructs a new PickleStepArgument.
                 * @memberof io.cucumber.messages
                 * @classdesc A wrapper for either a doc string or a table.
                 * @implements IPickleStepArgument
                 * @constructor
                 * @param {io.cucumber.messages.IPickleStepArgument=} [properties] Properties to set
                 */
                function PickleStepArgument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PickleStepArgument docString.
                 * @member {io.cucumber.messages.PickleStepArgument.IPickleDocString|null|undefined} docString
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @instance
                 */
                PickleStepArgument.prototype.docString = null;

                /**
                 * PickleStepArgument dataTable.
                 * @member {io.cucumber.messages.PickleStepArgument.IPickleTable|null|undefined} dataTable
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @instance
                 */
                PickleStepArgument.prototype.dataTable = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * PickleStepArgument message.
                 * @member {"docString"|"dataTable"|undefined} message
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @instance
                 */
                Object.defineProperty(PickleStepArgument.prototype, "message", {
                    get: $util.oneOfGetter($oneOfFields = ["docString", "dataTable"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new PickleStepArgument instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {io.cucumber.messages.IPickleStepArgument=} [properties] Properties to set
                 * @returns {io.cucumber.messages.PickleStepArgument} PickleStepArgument instance
                 */
                PickleStepArgument.create = function create(properties) {
                    return new PickleStepArgument(properties);
                };

                /**
                 * Encodes the specified PickleStepArgument message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {io.cucumber.messages.IPickleStepArgument} message PickleStepArgument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PickleStepArgument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
                        $root.io.cucumber.messages.PickleStepArgument.PickleDocString.encode(message.docString, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.dataTable != null && Object.hasOwnProperty.call(message, "dataTable"))
                        $root.io.cucumber.messages.PickleStepArgument.PickleTable.encode(message.dataTable, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified PickleStepArgument message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {io.cucumber.messages.IPickleStepArgument} message PickleStepArgument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PickleStepArgument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PickleStepArgument message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.PickleStepArgument} PickleStepArgument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PickleStepArgument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.docString = $root.io.cucumber.messages.PickleStepArgument.PickleDocString.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.dataTable = $root.io.cucumber.messages.PickleStepArgument.PickleTable.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PickleStepArgument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.PickleStepArgument} PickleStepArgument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PickleStepArgument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PickleStepArgument message.
                 * @function verify
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PickleStepArgument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.docString != null && message.hasOwnProperty("docString")) {
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.PickleStepArgument.PickleDocString.verify(message.docString);
                            if (error)
                                return "docString." + error;
                        }
                    }
                    if (message.dataTable != null && message.hasOwnProperty("dataTable")) {
                        if (properties.message === 1)
                            return "message: multiple values";
                        properties.message = 1;
                        {
                            var error = $root.io.cucumber.messages.PickleStepArgument.PickleTable.verify(message.dataTable);
                            if (error)
                                return "dataTable." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a PickleStepArgument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.PickleStepArgument} PickleStepArgument
                 */
                PickleStepArgument.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.PickleStepArgument)
                        return object;
                    var message = new $root.io.cucumber.messages.PickleStepArgument();
                    if (object.docString != null) {
                        if (typeof object.docString !== "object")
                            throw TypeError(".io.cucumber.messages.PickleStepArgument.docString: object expected");
                        message.docString = $root.io.cucumber.messages.PickleStepArgument.PickleDocString.fromObject(object.docString);
                    }
                    if (object.dataTable != null) {
                        if (typeof object.dataTable !== "object")
                            throw TypeError(".io.cucumber.messages.PickleStepArgument.dataTable: object expected");
                        message.dataTable = $root.io.cucumber.messages.PickleStepArgument.PickleTable.fromObject(object.dataTable);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PickleStepArgument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @static
                 * @param {io.cucumber.messages.PickleStepArgument} message PickleStepArgument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PickleStepArgument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.docString != null && message.hasOwnProperty("docString")) {
                        object.docString = $root.io.cucumber.messages.PickleStepArgument.PickleDocString.toObject(message.docString, options);
                        if (options.oneofs)
                            object.message = "docString";
                    }
                    if (message.dataTable != null && message.hasOwnProperty("dataTable")) {
                        object.dataTable = $root.io.cucumber.messages.PickleStepArgument.PickleTable.toObject(message.dataTable, options);
                        if (options.oneofs)
                            object.message = "dataTable";
                    }
                    return object;
                };

                /**
                 * Converts this PickleStepArgument to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.PickleStepArgument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PickleStepArgument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                PickleStepArgument.PickleDocString = (function() {

                    /**
                     * Properties of a PickleDocString.
                     * @memberof io.cucumber.messages.PickleStepArgument
                     * @interface IPickleDocString
                     * @property {string|null} [mediaType] PickleDocString mediaType
                     * @property {string|null} [content] PickleDocString content
                     */

                    /**
                     * Constructs a new PickleDocString.
                     * @memberof io.cucumber.messages.PickleStepArgument
                     * @classdesc Represents a PickleDocString.
                     * @implements IPickleDocString
                     * @constructor
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleDocString=} [properties] Properties to set
                     */
                    function PickleDocString(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PickleDocString mediaType.
                     * @member {string} mediaType
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @instance
                     */
                    PickleDocString.prototype.mediaType = "";

                    /**
                     * PickleDocString content.
                     * @member {string} content
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @instance
                     */
                    PickleDocString.prototype.content = "";

                    /**
                     * Creates a new PickleDocString instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleDocString=} [properties] Properties to set
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleDocString} PickleDocString instance
                     */
                    PickleDocString.create = function create(properties) {
                        return new PickleDocString(properties);
                    };

                    /**
                     * Encodes the specified PickleDocString message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleDocString.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleDocString} message PickleDocString message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleDocString.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.mediaType);
                        if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
                        return writer;
                    };

                    /**
                     * Encodes the specified PickleDocString message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleDocString.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleDocString} message PickleDocString message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleDocString.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PickleDocString message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleDocString} PickleDocString
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleDocString.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument.PickleDocString();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.mediaType = reader.string();
                                break;
                            case 2:
                                message.content = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PickleDocString message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleDocString} PickleDocString
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleDocString.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PickleDocString message.
                     * @function verify
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PickleDocString.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                            if (!$util.isString(message.mediaType))
                                return "mediaType: string expected";
                        if (message.content != null && message.hasOwnProperty("content"))
                            if (!$util.isString(message.content))
                                return "content: string expected";
                        return null;
                    };

                    /**
                     * Creates a PickleDocString message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleDocString} PickleDocString
                     */
                    PickleDocString.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.PickleStepArgument.PickleDocString)
                            return object;
                        var message = new $root.io.cucumber.messages.PickleStepArgument.PickleDocString();
                        if (object.mediaType != null)
                            message.mediaType = String(object.mediaType);
                        if (object.content != null)
                            message.content = String(object.content);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PickleDocString message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.PickleDocString} message PickleDocString
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PickleDocString.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.mediaType = "";
                            object.content = "";
                        }
                        if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                            object.mediaType = message.mediaType;
                        if (message.content != null && message.hasOwnProperty("content"))
                            object.content = message.content;
                        return object;
                    };

                    /**
                     * Converts this PickleDocString to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleDocString
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PickleDocString.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PickleDocString;
                })();

                PickleStepArgument.PickleTable = (function() {

                    /**
                     * Properties of a PickleTable.
                     * @memberof io.cucumber.messages.PickleStepArgument
                     * @interface IPickleTable
                     * @property {Array.<io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow>|null} [rows] PickleTable rows
                     */

                    /**
                     * Constructs a new PickleTable.
                     * @memberof io.cucumber.messages.PickleStepArgument
                     * @classdesc Represents a PickleTable.
                     * @implements IPickleTable
                     * @constructor
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleTable=} [properties] Properties to set
                     */
                    function PickleTable(properties) {
                        this.rows = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PickleTable rows.
                     * @member {Array.<io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow>} rows
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @instance
                     */
                    PickleTable.prototype.rows = $util.emptyArray;

                    /**
                     * Creates a new PickleTable instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleTable=} [properties] Properties to set
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleTable} PickleTable instance
                     */
                    PickleTable.create = function create(properties) {
                        return new PickleTable(properties);
                    };

                    /**
                     * Encodes the specified PickleTable message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleTable} message PickleTable message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleTable.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.rows != null && message.rows.length)
                            for (var i = 0; i < message.rows.length; ++i)
                                $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.encode(message.rows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified PickleTable message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.IPickleTable} message PickleTable message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PickleTable.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a PickleTable message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleTable} PickleTable
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleTable.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.rows && message.rows.length))
                                    message.rows = [];
                                message.rows.push($root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a PickleTable message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleTable} PickleTable
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PickleTable.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a PickleTable message.
                     * @function verify
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PickleTable.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.rows != null && message.hasOwnProperty("rows")) {
                            if (!Array.isArray(message.rows))
                                return "rows: array expected";
                            for (var i = 0; i < message.rows.length; ++i) {
                                var error = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.verify(message.rows[i]);
                                if (error)
                                    return "rows." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a PickleTable message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.PickleStepArgument.PickleTable} PickleTable
                     */
                    PickleTable.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.PickleStepArgument.PickleTable)
                            return object;
                        var message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable();
                        if (object.rows) {
                            if (!Array.isArray(object.rows))
                                throw TypeError(".io.cucumber.messages.PickleStepArgument.PickleTable.rows: array expected");
                            message.rows = [];
                            for (var i = 0; i < object.rows.length; ++i) {
                                if (typeof object.rows[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.PickleStepArgument.PickleTable.rows: object expected");
                                message.rows[i] = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.fromObject(object.rows[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a PickleTable message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @static
                     * @param {io.cucumber.messages.PickleStepArgument.PickleTable} message PickleTable
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PickleTable.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.rows = [];
                        if (message.rows && message.rows.length) {
                            object.rows = [];
                            for (var j = 0; j < message.rows.length; ++j)
                                object.rows[j] = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.toObject(message.rows[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this PickleTable to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PickleTable.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    PickleTable.PickleTableRow = (function() {

                        /**
                         * Properties of a PickleTableRow.
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                         * @interface IPickleTableRow
                         * @property {Array.<io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell>|null} [cells] PickleTableRow cells
                         */

                        /**
                         * Constructs a new PickleTableRow.
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable
                         * @classdesc Represents a PickleTableRow.
                         * @implements IPickleTableRow
                         * @constructor
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow=} [properties] Properties to set
                         */
                        function PickleTableRow(properties) {
                            this.cells = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PickleTableRow cells.
                         * @member {Array.<io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell>} cells
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @instance
                         */
                        PickleTableRow.prototype.cells = $util.emptyArray;

                        /**
                         * Creates a new PickleTableRow instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow=} [properties] Properties to set
                         * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} PickleTableRow instance
                         */
                        PickleTableRow.create = function create(properties) {
                            return new PickleTableRow(properties);
                        };

                        /**
                         * Encodes the specified PickleTableRow message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow} message PickleTableRow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PickleTableRow.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.cells != null && message.cells.length)
                                for (var i = 0; i < message.cells.length; ++i)
                                    $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.encode(message.cells[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified PickleTableRow message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.IPickleTableRow} message PickleTableRow message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PickleTableRow.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PickleTableRow message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} PickleTableRow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PickleTableRow.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    if (!(message.cells && message.cells.length))
                                        message.cells = [];
                                    message.cells.push($root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PickleTableRow message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} PickleTableRow
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PickleTableRow.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PickleTableRow message.
                         * @function verify
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PickleTableRow.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.cells != null && message.hasOwnProperty("cells")) {
                                if (!Array.isArray(message.cells))
                                    return "cells: array expected";
                                for (var i = 0; i < message.cells.length; ++i) {
                                    var error = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.verify(message.cells[i]);
                                    if (error)
                                        return "cells." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a PickleTableRow message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} PickleTableRow
                         */
                        PickleTableRow.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow)
                                return object;
                            var message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow();
                            if (object.cells) {
                                if (!Array.isArray(object.cells))
                                    throw TypeError(".io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.cells: array expected");
                                message.cells = [];
                                for (var i = 0; i < object.cells.length; ++i) {
                                    if (typeof object.cells[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.cells: object expected");
                                    message.cells[i] = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.fromObject(object.cells[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a PickleTableRow message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @static
                         * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow} message PickleTableRow
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PickleTableRow.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.cells = [];
                            if (message.cells && message.cells.length) {
                                object.cells = [];
                                for (var j = 0; j < message.cells.length; ++j)
                                    object.cells[j] = $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.toObject(message.cells[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this PickleTableRow to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PickleTableRow.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        PickleTableRow.PickleTableCell = (function() {

                            /**
                             * Properties of a PickleTableCell.
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                             * @interface IPickleTableCell
                             * @property {string|null} [value] PickleTableCell value
                             */

                            /**
                             * Constructs a new PickleTableCell.
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow
                             * @classdesc Represents a PickleTableCell.
                             * @implements IPickleTableCell
                             * @constructor
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell=} [properties] Properties to set
                             */
                            function PickleTableCell(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * PickleTableCell value.
                             * @member {string} value
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @instance
                             */
                            PickleTableCell.prototype.value = "";

                            /**
                             * Creates a new PickleTableCell instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell=} [properties] Properties to set
                             * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} PickleTableCell instance
                             */
                            PickleTableCell.create = function create(properties) {
                                return new PickleTableCell(properties);
                            };

                            /**
                             * Encodes the specified PickleTableCell message. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell} message PickleTableCell message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PickleTableCell.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                                return writer;
                            };

                            /**
                             * Encodes the specified PickleTableCell message, length delimited. Does not implicitly {@link io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.IPickleTableCell} message PickleTableCell message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PickleTableCell.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a PickleTableCell message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} PickleTableCell
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PickleTableCell.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.value = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a PickleTableCell message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} PickleTableCell
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PickleTableCell.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a PickleTableCell message.
                             * @function verify
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            PickleTableCell.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.value != null && message.hasOwnProperty("value"))
                                    if (!$util.isString(message.value))
                                        return "value: string expected";
                                return null;
                            };

                            /**
                             * Creates a PickleTableCell message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} PickleTableCell
                             */
                            PickleTableCell.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell)
                                    return object;
                                var message = new $root.io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell();
                                if (object.value != null)
                                    message.value = String(object.value);
                                return message;
                            };

                            /**
                             * Creates a plain object from a PickleTableCell message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @static
                             * @param {io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell} message PickleTableCell
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            PickleTableCell.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.value = "";
                                if (message.value != null && message.hasOwnProperty("value"))
                                    object.value = message.value;
                                return object;
                            };

                            /**
                             * Converts this PickleTableCell to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            PickleTableCell.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return PickleTableCell;
                        })();

                        return PickleTableRow;
                    })();

                    return PickleTable;
                })();

                return PickleStepArgument;
            })();

            messages.TestCase = (function() {

                /**
                 * Properties of a TestCase.
                 * @memberof io.cucumber.messages
                 * @interface ITestCase
                 * @property {string|null} [id] TestCase id
                 * @property {string|null} [pickleId] TestCase pickleId
                 * @property {Array.<io.cucumber.messages.TestCase.ITestStep>|null} [testSteps] TestCase testSteps
                 */

                /**
                 * Constructs a new TestCase.
                 * @memberof io.cucumber.messages
                 * @classdesc A `TestCase` contains a sequence of `TestStep`s.
                 * @implements ITestCase
                 * @constructor
                 * @param {io.cucumber.messages.ITestCase=} [properties] Properties to set
                 */
                function TestCase(properties) {
                    this.testSteps = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestCase id.
                 * @member {string} id
                 * @memberof io.cucumber.messages.TestCase
                 * @instance
                 */
                TestCase.prototype.id = "";

                /**
                 * TestCase pickleId.
                 * @member {string} pickleId
                 * @memberof io.cucumber.messages.TestCase
                 * @instance
                 */
                TestCase.prototype.pickleId = "";

                /**
                 * TestCase testSteps.
                 * @member {Array.<io.cucumber.messages.TestCase.ITestStep>} testSteps
                 * @memberof io.cucumber.messages.TestCase
                 * @instance
                 */
                TestCase.prototype.testSteps = $util.emptyArray;

                /**
                 * Creates a new TestCase instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {io.cucumber.messages.ITestCase=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestCase} TestCase instance
                 */
                TestCase.create = function create(properties) {
                    return new TestCase(properties);
                };

                /**
                 * Encodes the specified TestCase message. Does not implicitly {@link io.cucumber.messages.TestCase.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {io.cucumber.messages.ITestCase} message TestCase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCase.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.pickleId != null && Object.hasOwnProperty.call(message, "pickleId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.pickleId);
                    if (message.testSteps != null && message.testSteps.length)
                        for (var i = 0; i < message.testSteps.length; ++i)
                            $root.io.cucumber.messages.TestCase.TestStep.encode(message.testSteps[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TestCase message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCase.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {io.cucumber.messages.ITestCase} message TestCase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCase.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestCase message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestCase} TestCase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCase.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCase();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.pickleId = reader.string();
                            break;
                        case 3:
                            if (!(message.testSteps && message.testSteps.length))
                                message.testSteps = [];
                            message.testSteps.push($root.io.cucumber.messages.TestCase.TestStep.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestCase message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestCase} TestCase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCase.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestCase message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestCase.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        if (!$util.isString(message.pickleId))
                            return "pickleId: string expected";
                    if (message.testSteps != null && message.hasOwnProperty("testSteps")) {
                        if (!Array.isArray(message.testSteps))
                            return "testSteps: array expected";
                        for (var i = 0; i < message.testSteps.length; ++i) {
                            var error = $root.io.cucumber.messages.TestCase.TestStep.verify(message.testSteps[i]);
                            if (error)
                                return "testSteps." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TestCase message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestCase} TestCase
                 */
                TestCase.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestCase)
                        return object;
                    var message = new $root.io.cucumber.messages.TestCase();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.pickleId != null)
                        message.pickleId = String(object.pickleId);
                    if (object.testSteps) {
                        if (!Array.isArray(object.testSteps))
                            throw TypeError(".io.cucumber.messages.TestCase.testSteps: array expected");
                        message.testSteps = [];
                        for (var i = 0; i < object.testSteps.length; ++i) {
                            if (typeof object.testSteps[i] !== "object")
                                throw TypeError(".io.cucumber.messages.TestCase.testSteps: object expected");
                            message.testSteps[i] = $root.io.cucumber.messages.TestCase.TestStep.fromObject(object.testSteps[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TestCase message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestCase
                 * @static
                 * @param {io.cucumber.messages.TestCase} message TestCase
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestCase.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.testSteps = [];
                    if (options.defaults) {
                        object.id = "";
                        object.pickleId = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.pickleId != null && message.hasOwnProperty("pickleId"))
                        object.pickleId = message.pickleId;
                    if (message.testSteps && message.testSteps.length) {
                        object.testSteps = [];
                        for (var j = 0; j < message.testSteps.length; ++j)
                            object.testSteps[j] = $root.io.cucumber.messages.TestCase.TestStep.toObject(message.testSteps[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TestCase to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestCase
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestCase.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                TestCase.TestStep = (function() {

                    /**
                     * Properties of a TestStep.
                     * @memberof io.cucumber.messages.TestCase
                     * @interface ITestStep
                     * @property {string|null} [id] TestStep id
                     * @property {string|null} [pickleStepId] TestStep pickleStepId
                     * @property {Array.<string>|null} [stepDefinitionIds] TestStep stepDefinitionIds
                     * @property {Array.<io.cucumber.messages.TestCase.TestStep.IStepMatchArgumentsList>|null} [stepMatchArgumentsLists] TestStep stepMatchArgumentsLists
                     * @property {string|null} [hookId] TestStep hookId
                     */

                    /**
                     * Constructs a new TestStep.
                     * @memberof io.cucumber.messages.TestCase
                     * @classdesc A `TestStep` is derived from either a `PickleStep`
                     * combined with a `StepDefinition`, or from a `Hook`.
                     * @implements ITestStep
                     * @constructor
                     * @param {io.cucumber.messages.TestCase.ITestStep=} [properties] Properties to set
                     */
                    function TestStep(properties) {
                        this.stepDefinitionIds = [];
                        this.stepMatchArgumentsLists = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TestStep id.
                     * @member {string} id
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.id = "";

                    /**
                     * TestStep pickleStepId.
                     * @member {string} pickleStepId
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.pickleStepId = "";

                    /**
                     * TestStep stepDefinitionIds.
                     * @member {Array.<string>} stepDefinitionIds
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.stepDefinitionIds = $util.emptyArray;

                    /**
                     * TestStep stepMatchArgumentsLists.
                     * @member {Array.<io.cucumber.messages.TestCase.TestStep.IStepMatchArgumentsList>} stepMatchArgumentsLists
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.stepMatchArgumentsLists = $util.emptyArray;

                    /**
                     * TestStep hookId.
                     * @member {string} hookId
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     */
                    TestStep.prototype.hookId = "";

                    /**
                     * Creates a new TestStep instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {io.cucumber.messages.TestCase.ITestStep=} [properties] Properties to set
                     * @returns {io.cucumber.messages.TestCase.TestStep} TestStep instance
                     */
                    TestStep.create = function create(properties) {
                        return new TestStep(properties);
                    };

                    /**
                     * Encodes the specified TestStep message. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {io.cucumber.messages.TestCase.ITestStep} message TestStep message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TestStep.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.pickleStepId != null && Object.hasOwnProperty.call(message, "pickleStepId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.pickleStepId);
                        if (message.stepDefinitionIds != null && message.stepDefinitionIds.length)
                            for (var i = 0; i < message.stepDefinitionIds.length; ++i)
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stepDefinitionIds[i]);
                        if (message.stepMatchArgumentsLists != null && message.stepMatchArgumentsLists.length)
                            for (var i = 0; i < message.stepMatchArgumentsLists.length; ++i)
                                $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.encode(message.stepMatchArgumentsLists[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.hookId != null && Object.hasOwnProperty.call(message, "hookId"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.hookId);
                        return writer;
                    };

                    /**
                     * Encodes the specified TestStep message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {io.cucumber.messages.TestCase.ITestStep} message TestStep message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TestStep.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TestStep message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.TestCase.TestStep} TestStep
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TestStep.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCase.TestStep();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.pickleStepId = reader.string();
                                break;
                            case 3:
                                if (!(message.stepDefinitionIds && message.stepDefinitionIds.length))
                                    message.stepDefinitionIds = [];
                                message.stepDefinitionIds.push(reader.string());
                                break;
                            case 4:
                                if (!(message.stepMatchArgumentsLists && message.stepMatchArgumentsLists.length))
                                    message.stepMatchArgumentsLists = [];
                                message.stepMatchArgumentsLists.push($root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.hookId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TestStep message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.TestCase.TestStep} TestStep
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TestStep.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TestStep message.
                     * @function verify
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TestStep.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.pickleStepId != null && message.hasOwnProperty("pickleStepId"))
                            if (!$util.isString(message.pickleStepId))
                                return "pickleStepId: string expected";
                        if (message.stepDefinitionIds != null && message.hasOwnProperty("stepDefinitionIds")) {
                            if (!Array.isArray(message.stepDefinitionIds))
                                return "stepDefinitionIds: array expected";
                            for (var i = 0; i < message.stepDefinitionIds.length; ++i)
                                if (!$util.isString(message.stepDefinitionIds[i]))
                                    return "stepDefinitionIds: string[] expected";
                        }
                        if (message.stepMatchArgumentsLists != null && message.hasOwnProperty("stepMatchArgumentsLists")) {
                            if (!Array.isArray(message.stepMatchArgumentsLists))
                                return "stepMatchArgumentsLists: array expected";
                            for (var i = 0; i < message.stepMatchArgumentsLists.length; ++i) {
                                var error = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.verify(message.stepMatchArgumentsLists[i]);
                                if (error)
                                    return "stepMatchArgumentsLists." + error;
                            }
                        }
                        if (message.hookId != null && message.hasOwnProperty("hookId"))
                            if (!$util.isString(message.hookId))
                                return "hookId: string expected";
                        return null;
                    };

                    /**
                     * Creates a TestStep message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.TestCase.TestStep} TestStep
                     */
                    TestStep.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.TestCase.TestStep)
                            return object;
                        var message = new $root.io.cucumber.messages.TestCase.TestStep();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.pickleStepId != null)
                            message.pickleStepId = String(object.pickleStepId);
                        if (object.stepDefinitionIds) {
                            if (!Array.isArray(object.stepDefinitionIds))
                                throw TypeError(".io.cucumber.messages.TestCase.TestStep.stepDefinitionIds: array expected");
                            message.stepDefinitionIds = [];
                            for (var i = 0; i < object.stepDefinitionIds.length; ++i)
                                message.stepDefinitionIds[i] = String(object.stepDefinitionIds[i]);
                        }
                        if (object.stepMatchArgumentsLists) {
                            if (!Array.isArray(object.stepMatchArgumentsLists))
                                throw TypeError(".io.cucumber.messages.TestCase.TestStep.stepMatchArgumentsLists: array expected");
                            message.stepMatchArgumentsLists = [];
                            for (var i = 0; i < object.stepMatchArgumentsLists.length; ++i) {
                                if (typeof object.stepMatchArgumentsLists[i] !== "object")
                                    throw TypeError(".io.cucumber.messages.TestCase.TestStep.stepMatchArgumentsLists: object expected");
                                message.stepMatchArgumentsLists[i] = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.fromObject(object.stepMatchArgumentsLists[i]);
                            }
                        }
                        if (object.hookId != null)
                            message.hookId = String(object.hookId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TestStep message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @static
                     * @param {io.cucumber.messages.TestCase.TestStep} message TestStep
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TestStep.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.stepDefinitionIds = [];
                            object.stepMatchArgumentsLists = [];
                        }
                        if (options.defaults) {
                            object.id = "";
                            object.pickleStepId = "";
                            object.hookId = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.pickleStepId != null && message.hasOwnProperty("pickleStepId"))
                            object.pickleStepId = message.pickleStepId;
                        if (message.stepDefinitionIds && message.stepDefinitionIds.length) {
                            object.stepDefinitionIds = [];
                            for (var j = 0; j < message.stepDefinitionIds.length; ++j)
                                object.stepDefinitionIds[j] = message.stepDefinitionIds[j];
                        }
                        if (message.stepMatchArgumentsLists && message.stepMatchArgumentsLists.length) {
                            object.stepMatchArgumentsLists = [];
                            for (var j = 0; j < message.stepMatchArgumentsLists.length; ++j)
                                object.stepMatchArgumentsLists[j] = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.toObject(message.stepMatchArgumentsLists[j], options);
                        }
                        if (message.hookId != null && message.hasOwnProperty("hookId"))
                            object.hookId = message.hookId;
                        return object;
                    };

                    /**
                     * Converts this TestStep to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.TestCase.TestStep
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TestStep.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    TestStep.StepMatchArgumentsList = (function() {

                        /**
                         * Properties of a StepMatchArgumentsList.
                         * @memberof io.cucumber.messages.TestCase.TestStep
                         * @interface IStepMatchArgumentsList
                         * @property {Array.<io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.IStepMatchArgument>|null} [stepMatchArguments] StepMatchArgumentsList stepMatchArguments
                         */

                        /**
                         * Constructs a new StepMatchArgumentsList.
                         * @memberof io.cucumber.messages.TestCase.TestStep
                         * @classdesc Represents a StepMatchArgumentsList.
                         * @implements IStepMatchArgumentsList
                         * @constructor
                         * @param {io.cucumber.messages.TestCase.TestStep.IStepMatchArgumentsList=} [properties] Properties to set
                         */
                        function StepMatchArgumentsList(properties) {
                            this.stepMatchArguments = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * StepMatchArgumentsList stepMatchArguments.
                         * @member {Array.<io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.IStepMatchArgument>} stepMatchArguments
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @instance
                         */
                        StepMatchArgumentsList.prototype.stepMatchArguments = $util.emptyArray;

                        /**
                         * Creates a new StepMatchArgumentsList instance using the specified properties.
                         * @function create
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @static
                         * @param {io.cucumber.messages.TestCase.TestStep.IStepMatchArgumentsList=} [properties] Properties to set
                         * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList} StepMatchArgumentsList instance
                         */
                        StepMatchArgumentsList.create = function create(properties) {
                            return new StepMatchArgumentsList(properties);
                        };

                        /**
                         * Encodes the specified StepMatchArgumentsList message. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.verify|verify} messages.
                         * @function encode
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @static
                         * @param {io.cucumber.messages.TestCase.TestStep.IStepMatchArgumentsList} message StepMatchArgumentsList message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        StepMatchArgumentsList.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.stepMatchArguments != null && message.stepMatchArguments.length)
                                for (var i = 0; i < message.stepMatchArguments.length; ++i)
                                    $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.encode(message.stepMatchArguments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified StepMatchArgumentsList message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @static
                         * @param {io.cucumber.messages.TestCase.TestStep.IStepMatchArgumentsList} message StepMatchArgumentsList message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        StepMatchArgumentsList.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a StepMatchArgumentsList message from the specified reader or buffer.
                         * @function decode
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList} StepMatchArgumentsList
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        StepMatchArgumentsList.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    if (!(message.stepMatchArguments && message.stepMatchArguments.length))
                                        message.stepMatchArguments = [];
                                    message.stepMatchArguments.push($root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a StepMatchArgumentsList message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList} StepMatchArgumentsList
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        StepMatchArgumentsList.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a StepMatchArgumentsList message.
                         * @function verify
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        StepMatchArgumentsList.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.stepMatchArguments != null && message.hasOwnProperty("stepMatchArguments")) {
                                if (!Array.isArray(message.stepMatchArguments))
                                    return "stepMatchArguments: array expected";
                                for (var i = 0; i < message.stepMatchArguments.length; ++i) {
                                    var error = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.verify(message.stepMatchArguments[i]);
                                    if (error)
                                        return "stepMatchArguments." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a StepMatchArgumentsList message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList} StepMatchArgumentsList
                         */
                        StepMatchArgumentsList.fromObject = function fromObject(object) {
                            if (object instanceof $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList)
                                return object;
                            var message = new $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList();
                            if (object.stepMatchArguments) {
                                if (!Array.isArray(object.stepMatchArguments))
                                    throw TypeError(".io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.stepMatchArguments: array expected");
                                message.stepMatchArguments = [];
                                for (var i = 0; i < object.stepMatchArguments.length; ++i) {
                                    if (typeof object.stepMatchArguments[i] !== "object")
                                        throw TypeError(".io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.stepMatchArguments: object expected");
                                    message.stepMatchArguments[i] = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.fromObject(object.stepMatchArguments[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a StepMatchArgumentsList message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @static
                         * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList} message StepMatchArgumentsList
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        StepMatchArgumentsList.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.stepMatchArguments = [];
                            if (message.stepMatchArguments && message.stepMatchArguments.length) {
                                object.stepMatchArguments = [];
                                for (var j = 0; j < message.stepMatchArguments.length; ++j)
                                    object.stepMatchArguments[j] = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.toObject(message.stepMatchArguments[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this StepMatchArgumentsList to JSON.
                         * @function toJSON
                         * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        StepMatchArgumentsList.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        StepMatchArgumentsList.StepMatchArgument = (function() {

                            /**
                             * Properties of a StepMatchArgument.
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                             * @interface IStepMatchArgument
                             * @property {string|null} [parameterTypeName] StepMatchArgument parameterTypeName
                             * @property {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.IGroup|null} [group] Represents the outermost capture group of an argument. This message closely matches the
                             * `Group` class in the `cucumber-expressions` library.
                             */

                            /**
                             * Constructs a new StepMatchArgument.
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList
                             * @classdesc Represents a single argument extracted from a step match and passed to a step definition.
                             * This is used for the following purposes:
                             * - Construct an argument to pass to a step definition (possibly through a parameter type transform)
                             * - Highlight the matched parameter in rich formatters such as the HTML formatter
                             * 
                             * This message closely matches the `Argument` class in the `cucumber-expressions` library.
                             * @implements IStepMatchArgument
                             * @constructor
                             * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.IStepMatchArgument=} [properties] Properties to set
                             */
                            function StepMatchArgument(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * StepMatchArgument parameterTypeName.
                             * @member {string} parameterTypeName
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @instance
                             */
                            StepMatchArgument.prototype.parameterTypeName = "";

                            /**
                             * Represents the outermost capture group of an argument. This message closely matches the
                             * `Group` class in the `cucumber-expressions` library.
                             * @member {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.IGroup|null|undefined} group
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @instance
                             */
                            StepMatchArgument.prototype.group = null;

                            /**
                             * Creates a new StepMatchArgument instance using the specified properties.
                             * @function create
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @static
                             * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.IStepMatchArgument=} [properties] Properties to set
                             * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument} StepMatchArgument instance
                             */
                            StepMatchArgument.create = function create(properties) {
                                return new StepMatchArgument(properties);
                            };

                            /**
                             * Encodes the specified StepMatchArgument message. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.verify|verify} messages.
                             * @function encode
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @static
                             * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.IStepMatchArgument} message StepMatchArgument message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            StepMatchArgument.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.parameterTypeName != null && Object.hasOwnProperty.call(message, "parameterTypeName"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.parameterTypeName);
                                if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                                    $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.encode(message.group, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified StepMatchArgument message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @static
                             * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.IStepMatchArgument} message StepMatchArgument message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            StepMatchArgument.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a StepMatchArgument message from the specified reader or buffer.
                             * @function decode
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument} StepMatchArgument
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            StepMatchArgument.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.parameterTypeName = reader.string();
                                        break;
                                    case 2:
                                        message.group = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a StepMatchArgument message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument} StepMatchArgument
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            StepMatchArgument.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a StepMatchArgument message.
                             * @function verify
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            StepMatchArgument.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.parameterTypeName != null && message.hasOwnProperty("parameterTypeName"))
                                    if (!$util.isString(message.parameterTypeName))
                                        return "parameterTypeName: string expected";
                                if (message.group != null && message.hasOwnProperty("group")) {
                                    var error = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.verify(message.group);
                                    if (error)
                                        return "group." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a StepMatchArgument message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument} StepMatchArgument
                             */
                            StepMatchArgument.fromObject = function fromObject(object) {
                                if (object instanceof $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument)
                                    return object;
                                var message = new $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument();
                                if (object.parameterTypeName != null)
                                    message.parameterTypeName = String(object.parameterTypeName);
                                if (object.group != null) {
                                    if (typeof object.group !== "object")
                                        throw TypeError(".io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.group: object expected");
                                    message.group = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.fromObject(object.group);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a StepMatchArgument message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @static
                             * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument} message StepMatchArgument
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            StepMatchArgument.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.parameterTypeName = "";
                                    object.group = null;
                                }
                                if (message.parameterTypeName != null && message.hasOwnProperty("parameterTypeName"))
                                    object.parameterTypeName = message.parameterTypeName;
                                if (message.group != null && message.hasOwnProperty("group"))
                                    object.group = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.toObject(message.group, options);
                                return object;
                            };

                            /**
                             * Converts this StepMatchArgument to JSON.
                             * @function toJSON
                             * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            StepMatchArgument.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            StepMatchArgument.Group = (function() {

                                /**
                                 * Properties of a Group.
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                                 * @interface IGroup
                                 * @property {number|null} [start] Group start
                                 * @property {string|null} [value] Group value
                                 * @property {Array.<io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.IGroup>|null} [children] Group children
                                 */

                                /**
                                 * Constructs a new Group.
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument
                                 * @classdesc Represents a Group.
                                 * @implements IGroup
                                 * @constructor
                                 * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.IGroup=} [properties] Properties to set
                                 */
                                function Group(properties) {
                                    this.children = [];
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Group start.
                                 * @member {number} start
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @instance
                                 */
                                Group.prototype.start = 0;

                                /**
                                 * Group value.
                                 * @member {string} value
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @instance
                                 */
                                Group.prototype.value = "";

                                /**
                                 * Group children.
                                 * @member {Array.<io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.IGroup>} children
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @instance
                                 */
                                Group.prototype.children = $util.emptyArray;

                                /**
                                 * Creates a new Group instance using the specified properties.
                                 * @function create
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @static
                                 * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.IGroup=} [properties] Properties to set
                                 * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group} Group instance
                                 */
                                Group.create = function create(properties) {
                                    return new Group(properties);
                                };

                                /**
                                 * Encodes the specified Group message. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.verify|verify} messages.
                                 * @function encode
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @static
                                 * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.IGroup} message Group message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Group.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.start);
                                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                                    if (message.children != null && message.children.length)
                                        for (var i = 0; i < message.children.length; ++i)
                                            $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.encode(message.children[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Group message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @static
                                 * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.IGroup} message Group message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Group.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes a Group message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group} Group
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Group.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.start = reader.uint32();
                                            break;
                                        case 2:
                                            message.value = reader.string();
                                            break;
                                        case 3:
                                            if (!(message.children && message.children.length))
                                                message.children = [];
                                            message.children.push($root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.decode(reader, reader.uint32()));
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes a Group message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group} Group
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Group.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies a Group message.
                                 * @function verify
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Group.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.start != null && message.hasOwnProperty("start"))
                                        if (!$util.isInteger(message.start))
                                            return "start: integer expected";
                                    if (message.value != null && message.hasOwnProperty("value"))
                                        if (!$util.isString(message.value))
                                            return "value: string expected";
                                    if (message.children != null && message.hasOwnProperty("children")) {
                                        if (!Array.isArray(message.children))
                                            return "children: array expected";
                                        for (var i = 0; i < message.children.length; ++i) {
                                            var error = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.verify(message.children[i]);
                                            if (error)
                                                return "children." + error;
                                        }
                                    }
                                    return null;
                                };

                                /**
                                 * Creates a Group message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group} Group
                                 */
                                Group.fromObject = function fromObject(object) {
                                    if (object instanceof $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group)
                                        return object;
                                    var message = new $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group();
                                    if (object.start != null)
                                        message.start = object.start >>> 0;
                                    if (object.value != null)
                                        message.value = String(object.value);
                                    if (object.children) {
                                        if (!Array.isArray(object.children))
                                            throw TypeError(".io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.children: array expected");
                                        message.children = [];
                                        for (var i = 0; i < object.children.length; ++i) {
                                            if (typeof object.children[i] !== "object")
                                                throw TypeError(".io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.children: object expected");
                                            message.children[i] = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.fromObject(object.children[i]);
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a Group message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @static
                                 * @param {io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group} message Group
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Group.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.arrays || options.defaults)
                                        object.children = [];
                                    if (options.defaults) {
                                        object.start = 0;
                                        object.value = "";
                                    }
                                    if (message.start != null && message.hasOwnProperty("start"))
                                        object.start = message.start;
                                    if (message.value != null && message.hasOwnProperty("value"))
                                        object.value = message.value;
                                    if (message.children && message.children.length) {
                                        object.children = [];
                                        for (var j = 0; j < message.children.length; ++j)
                                            object.children[j] = $root.io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group.toObject(message.children[j], options);
                                    }
                                    return object;
                                };

                                /**
                                 * Converts this Group to JSON.
                                 * @function toJSON
                                 * @memberof io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Group.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                return Group;
                            })();

                            return StepMatchArgument;
                        })();

                        return StepMatchArgumentsList;
                    })();

                    return TestStep;
                })();

                return TestCase;
            })();

            messages.TestRunStarted = (function() {

                /**
                 * Properties of a TestRunStarted.
                 * @memberof io.cucumber.messages
                 * @interface ITestRunStarted
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestRunStarted timestamp
                 */

                /**
                 * Constructs a new TestRunStarted.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestRunStarted.
                 * @implements ITestRunStarted
                 * @constructor
                 * @param {io.cucumber.messages.ITestRunStarted=} [properties] Properties to set
                 */
                function TestRunStarted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestRunStarted timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @instance
                 */
                TestRunStarted.prototype.timestamp = null;

                /**
                 * Creates a new TestRunStarted instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {io.cucumber.messages.ITestRunStarted=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestRunStarted} TestRunStarted instance
                 */
                TestRunStarted.create = function create(properties) {
                    return new TestRunStarted(properties);
                };

                /**
                 * Encodes the specified TestRunStarted message. Does not implicitly {@link io.cucumber.messages.TestRunStarted.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {io.cucumber.messages.ITestRunStarted} message TestRunStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestRunStarted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TestRunStarted message, length delimited. Does not implicitly {@link io.cucumber.messages.TestRunStarted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {io.cucumber.messages.ITestRunStarted} message TestRunStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestRunStarted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestRunStarted message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestRunStarted} TestRunStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestRunStarted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestRunStarted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestRunStarted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestRunStarted} TestRunStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestRunStarted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestRunStarted message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestRunStarted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TestRunStarted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestRunStarted} TestRunStarted
                 */
                TestRunStarted.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestRunStarted)
                        return object;
                    var message = new $root.io.cucumber.messages.TestRunStarted();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestRunStarted.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TestRunStarted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @static
                 * @param {io.cucumber.messages.TestRunStarted} message TestRunStarted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestRunStarted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.timestamp = null;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    return object;
                };

                /**
                 * Converts this TestRunStarted to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestRunStarted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestRunStarted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestRunStarted;
            })();

            messages.TestCaseStarted = (function() {

                /**
                 * Properties of a TestCaseStarted.
                 * @memberof io.cucumber.messages
                 * @interface ITestCaseStarted
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestCaseStarted timestamp
                 * @property {number|null} [attempt] The first attempt should have value 0, and for each retry the value
                 * should increase by 1.
                 * @property {string|null} [testCaseId] TestCaseStarted testCaseId
                 * @property {string|null} [id] Because a `TestCase` can be run multiple times (in case of a retry),
                 * we use this field to group messages relating to the same attempt.
                 */

                /**
                 * Constructs a new TestCaseStarted.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestCaseStarted.
                 * @implements ITestCaseStarted
                 * @constructor
                 * @param {io.cucumber.messages.ITestCaseStarted=} [properties] Properties to set
                 */
                function TestCaseStarted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestCaseStarted timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.timestamp = null;

                /**
                 * The first attempt should have value 0, and for each retry the value
                 * should increase by 1.
                 * @member {number} attempt
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.attempt = 0;

                /**
                 * TestCaseStarted testCaseId.
                 * @member {string} testCaseId
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.testCaseId = "";

                /**
                 * Because a `TestCase` can be run multiple times (in case of a retry),
                 * we use this field to group messages relating to the same attempt.
                 * @member {string} id
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 */
                TestCaseStarted.prototype.id = "";

                /**
                 * Creates a new TestCaseStarted instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {io.cucumber.messages.ITestCaseStarted=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestCaseStarted} TestCaseStarted instance
                 */
                TestCaseStarted.create = function create(properties) {
                    return new TestCaseStarted(properties);
                };

                /**
                 * Encodes the specified TestCaseStarted message. Does not implicitly {@link io.cucumber.messages.TestCaseStarted.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {io.cucumber.messages.ITestCaseStarted} message TestCaseStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCaseStarted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.attempt != null && Object.hasOwnProperty.call(message, "attempt"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.attempt);
                    if (message.testCaseId != null && Object.hasOwnProperty.call(message, "testCaseId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.testCaseId);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.id);
                    return writer;
                };

                /**
                 * Encodes the specified TestCaseStarted message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCaseStarted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {io.cucumber.messages.ITestCaseStarted} message TestCaseStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCaseStarted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestCaseStarted message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestCaseStarted} TestCaseStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCaseStarted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCaseStarted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.attempt = reader.uint32();
                            break;
                        case 4:
                            message.testCaseId = reader.string();
                            break;
                        case 5:
                            message.id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestCaseStarted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestCaseStarted} TestCaseStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCaseStarted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestCaseStarted message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestCaseStarted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.attempt != null && message.hasOwnProperty("attempt"))
                        if (!$util.isInteger(message.attempt))
                            return "attempt: integer expected";
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        if (!$util.isString(message.testCaseId))
                            return "testCaseId: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    return null;
                };

                /**
                 * Creates a TestCaseStarted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestCaseStarted} TestCaseStarted
                 */
                TestCaseStarted.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestCaseStarted)
                        return object;
                    var message = new $root.io.cucumber.messages.TestCaseStarted();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestCaseStarted.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.attempt != null)
                        message.attempt = object.attempt >>> 0;
                    if (object.testCaseId != null)
                        message.testCaseId = String(object.testCaseId);
                    if (object.id != null)
                        message.id = String(object.id);
                    return message;
                };

                /**
                 * Creates a plain object from a TestCaseStarted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @static
                 * @param {io.cucumber.messages.TestCaseStarted} message TestCaseStarted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestCaseStarted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.timestamp = null;
                        object.attempt = 0;
                        object.testCaseId = "";
                        object.id = "";
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.attempt != null && message.hasOwnProperty("attempt"))
                        object.attempt = message.attempt;
                    if (message.testCaseId != null && message.hasOwnProperty("testCaseId"))
                        object.testCaseId = message.testCaseId;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    return object;
                };

                /**
                 * Converts this TestCaseStarted to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestCaseStarted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestCaseStarted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestCaseStarted;
            })();

            messages.TestCaseFinished = (function() {

                /**
                 * Properties of a TestCaseFinished.
                 * @memberof io.cucumber.messages
                 * @interface ITestCaseFinished
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestCaseFinished timestamp
                 * @property {string|null} [testCaseStartedId] TestCaseFinished testCaseStartedId
                 */

                /**
                 * Constructs a new TestCaseFinished.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestCaseFinished.
                 * @implements ITestCaseFinished
                 * @constructor
                 * @param {io.cucumber.messages.ITestCaseFinished=} [properties] Properties to set
                 */
                function TestCaseFinished(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestCaseFinished timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @instance
                 */
                TestCaseFinished.prototype.timestamp = null;

                /**
                 * TestCaseFinished testCaseStartedId.
                 * @member {string} testCaseStartedId
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @instance
                 */
                TestCaseFinished.prototype.testCaseStartedId = "";

                /**
                 * Creates a new TestCaseFinished instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {io.cucumber.messages.ITestCaseFinished=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestCaseFinished} TestCaseFinished instance
                 */
                TestCaseFinished.create = function create(properties) {
                    return new TestCaseFinished(properties);
                };

                /**
                 * Encodes the specified TestCaseFinished message. Does not implicitly {@link io.cucumber.messages.TestCaseFinished.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {io.cucumber.messages.ITestCaseFinished} message TestCaseFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCaseFinished.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.testCaseStartedId != null && Object.hasOwnProperty.call(message, "testCaseStartedId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testCaseStartedId);
                    return writer;
                };

                /**
                 * Encodes the specified TestCaseFinished message, length delimited. Does not implicitly {@link io.cucumber.messages.TestCaseFinished.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {io.cucumber.messages.ITestCaseFinished} message TestCaseFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestCaseFinished.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestCaseFinished message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestCaseFinished} TestCaseFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCaseFinished.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestCaseFinished();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.testCaseStartedId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestCaseFinished message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestCaseFinished} TestCaseFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestCaseFinished.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestCaseFinished message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestCaseFinished.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        if (!$util.isString(message.testCaseStartedId))
                            return "testCaseStartedId: string expected";
                    return null;
                };

                /**
                 * Creates a TestCaseFinished message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestCaseFinished} TestCaseFinished
                 */
                TestCaseFinished.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestCaseFinished)
                        return object;
                    var message = new $root.io.cucumber.messages.TestCaseFinished();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestCaseFinished.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.testCaseStartedId != null)
                        message.testCaseStartedId = String(object.testCaseStartedId);
                    return message;
                };

                /**
                 * Creates a plain object from a TestCaseFinished message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @static
                 * @param {io.cucumber.messages.TestCaseFinished} message TestCaseFinished
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestCaseFinished.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.timestamp = null;
                        object.testCaseStartedId = "";
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        object.testCaseStartedId = message.testCaseStartedId;
                    return object;
                };

                /**
                 * Converts this TestCaseFinished to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestCaseFinished
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestCaseFinished.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestCaseFinished;
            })();

            messages.TestStepStarted = (function() {

                /**
                 * Properties of a TestStepStarted.
                 * @memberof io.cucumber.messages
                 * @interface ITestStepStarted
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestStepStarted timestamp
                 * @property {string|null} [testStepId] TestStepStarted testStepId
                 * @property {string|null} [testCaseStartedId] TestStepStarted testCaseStartedId
                 */

                /**
                 * Constructs a new TestStepStarted.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestStepStarted.
                 * @implements ITestStepStarted
                 * @constructor
                 * @param {io.cucumber.messages.ITestStepStarted=} [properties] Properties to set
                 */
                function TestStepStarted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestStepStarted timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @instance
                 */
                TestStepStarted.prototype.timestamp = null;

                /**
                 * TestStepStarted testStepId.
                 * @member {string} testStepId
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @instance
                 */
                TestStepStarted.prototype.testStepId = "";

                /**
                 * TestStepStarted testCaseStartedId.
                 * @member {string} testCaseStartedId
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @instance
                 */
                TestStepStarted.prototype.testCaseStartedId = "";

                /**
                 * Creates a new TestStepStarted instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {io.cucumber.messages.ITestStepStarted=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestStepStarted} TestStepStarted instance
                 */
                TestStepStarted.create = function create(properties) {
                    return new TestStepStarted(properties);
                };

                /**
                 * Encodes the specified TestStepStarted message. Does not implicitly {@link io.cucumber.messages.TestStepStarted.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {io.cucumber.messages.ITestStepStarted} message TestStepStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestStepStarted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.testStepId != null && Object.hasOwnProperty.call(message, "testStepId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.testStepId);
                    if (message.testCaseStartedId != null && Object.hasOwnProperty.call(message, "testCaseStartedId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testCaseStartedId);
                    return writer;
                };

                /**
                 * Encodes the specified TestStepStarted message, length delimited. Does not implicitly {@link io.cucumber.messages.TestStepStarted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {io.cucumber.messages.ITestStepStarted} message TestStepStarted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestStepStarted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestStepStarted message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestStepStarted} TestStepStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestStepStarted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestStepStarted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.testStepId = reader.string();
                            break;
                        case 3:
                            message.testCaseStartedId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestStepStarted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestStepStarted} TestStepStarted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestStepStarted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestStepStarted message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestStepStarted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        if (!$util.isString(message.testStepId))
                            return "testStepId: string expected";
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        if (!$util.isString(message.testCaseStartedId))
                            return "testCaseStartedId: string expected";
                    return null;
                };

                /**
                 * Creates a TestStepStarted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestStepStarted} TestStepStarted
                 */
                TestStepStarted.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestStepStarted)
                        return object;
                    var message = new $root.io.cucumber.messages.TestStepStarted();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestStepStarted.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.testStepId != null)
                        message.testStepId = String(object.testStepId);
                    if (object.testCaseStartedId != null)
                        message.testCaseStartedId = String(object.testCaseStartedId);
                    return message;
                };

                /**
                 * Creates a plain object from a TestStepStarted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @static
                 * @param {io.cucumber.messages.TestStepStarted} message TestStepStarted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestStepStarted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.timestamp = null;
                        object.testStepId = "";
                        object.testCaseStartedId = "";
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        object.testStepId = message.testStepId;
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        object.testCaseStartedId = message.testCaseStartedId;
                    return object;
                };

                /**
                 * Converts this TestStepStarted to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestStepStarted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestStepStarted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestStepStarted;
            })();

            messages.TestStepFinished = (function() {

                /**
                 * Properties of a TestStepFinished.
                 * @memberof io.cucumber.messages
                 * @interface ITestStepFinished
                 * @property {io.cucumber.messages.TestStepFinished.ITestStepResult|null} [testStepResult] TestStepFinished testStepResult
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestStepFinished timestamp
                 * @property {string|null} [testStepId] TestStepFinished testStepId
                 * @property {string|null} [testCaseStartedId] TestStepFinished testCaseStartedId
                 */

                /**
                 * Constructs a new TestStepFinished.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestStepFinished.
                 * @implements ITestStepFinished
                 * @constructor
                 * @param {io.cucumber.messages.ITestStepFinished=} [properties] Properties to set
                 */
                function TestStepFinished(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestStepFinished testStepResult.
                 * @member {io.cucumber.messages.TestStepFinished.ITestStepResult|null|undefined} testStepResult
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 */
                TestStepFinished.prototype.testStepResult = null;

                /**
                 * TestStepFinished timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 */
                TestStepFinished.prototype.timestamp = null;

                /**
                 * TestStepFinished testStepId.
                 * @member {string} testStepId
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 */
                TestStepFinished.prototype.testStepId = "";

                /**
                 * TestStepFinished testCaseStartedId.
                 * @member {string} testCaseStartedId
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 */
                TestStepFinished.prototype.testCaseStartedId = "";

                /**
                 * Creates a new TestStepFinished instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {io.cucumber.messages.ITestStepFinished=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestStepFinished} TestStepFinished instance
                 */
                TestStepFinished.create = function create(properties) {
                    return new TestStepFinished(properties);
                };

                /**
                 * Encodes the specified TestStepFinished message. Does not implicitly {@link io.cucumber.messages.TestStepFinished.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {io.cucumber.messages.ITestStepFinished} message TestStepFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestStepFinished.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.testStepResult != null && Object.hasOwnProperty.call(message, "testStepResult"))
                        $root.io.cucumber.messages.TestStepFinished.TestStepResult.encode(message.testStepResult, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.testStepId != null && Object.hasOwnProperty.call(message, "testStepId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.testStepId);
                    if (message.testCaseStartedId != null && Object.hasOwnProperty.call(message, "testCaseStartedId"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.testCaseStartedId);
                    return writer;
                };

                /**
                 * Encodes the specified TestStepFinished message, length delimited. Does not implicitly {@link io.cucumber.messages.TestStepFinished.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {io.cucumber.messages.ITestStepFinished} message TestStepFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestStepFinished.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestStepFinished message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestStepFinished} TestStepFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestStepFinished.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestStepFinished();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.testStepResult = $root.io.cucumber.messages.TestStepFinished.TestStepResult.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.testStepId = reader.string();
                            break;
                        case 4:
                            message.testCaseStartedId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestStepFinished message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestStepFinished} TestStepFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestStepFinished.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestStepFinished message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestStepFinished.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.testStepResult != null && message.hasOwnProperty("testStepResult")) {
                        var error = $root.io.cucumber.messages.TestStepFinished.TestStepResult.verify(message.testStepResult);
                        if (error)
                            return "testStepResult." + error;
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        if (!$util.isString(message.testStepId))
                            return "testStepId: string expected";
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        if (!$util.isString(message.testCaseStartedId))
                            return "testCaseStartedId: string expected";
                    return null;
                };

                /**
                 * Creates a TestStepFinished message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestStepFinished} TestStepFinished
                 */
                TestStepFinished.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestStepFinished)
                        return object;
                    var message = new $root.io.cucumber.messages.TestStepFinished();
                    if (object.testStepResult != null) {
                        if (typeof object.testStepResult !== "object")
                            throw TypeError(".io.cucumber.messages.TestStepFinished.testStepResult: object expected");
                        message.testStepResult = $root.io.cucumber.messages.TestStepFinished.TestStepResult.fromObject(object.testStepResult);
                    }
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestStepFinished.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.testStepId != null)
                        message.testStepId = String(object.testStepId);
                    if (object.testCaseStartedId != null)
                        message.testCaseStartedId = String(object.testCaseStartedId);
                    return message;
                };

                /**
                 * Creates a plain object from a TestStepFinished message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @static
                 * @param {io.cucumber.messages.TestStepFinished} message TestStepFinished
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestStepFinished.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.testStepResult = null;
                        object.timestamp = null;
                        object.testStepId = "";
                        object.testCaseStartedId = "";
                    }
                    if (message.testStepResult != null && message.hasOwnProperty("testStepResult"))
                        object.testStepResult = $root.io.cucumber.messages.TestStepFinished.TestStepResult.toObject(message.testStepResult, options);
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.testStepId != null && message.hasOwnProperty("testStepId"))
                        object.testStepId = message.testStepId;
                    if (message.testCaseStartedId != null && message.hasOwnProperty("testCaseStartedId"))
                        object.testCaseStartedId = message.testCaseStartedId;
                    return object;
                };

                /**
                 * Converts this TestStepFinished to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestStepFinished
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestStepFinished.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                TestStepFinished.TestStepResult = (function() {

                    /**
                     * Properties of a TestStepResult.
                     * @memberof io.cucumber.messages.TestStepFinished
                     * @interface ITestStepResult
                     * @property {io.cucumber.messages.TestStepFinished.TestStepResult.Status|null} [status] TestStepResult status
                     * @property {string|null} [message] TestStepResult message
                     * @property {io.cucumber.messages.IDuration|null} [duration] TestStepResult duration
                     * @property {boolean|null} [willBeRetried] TestStepResult willBeRetried
                     */

                    /**
                     * Constructs a new TestStepResult.
                     * @memberof io.cucumber.messages.TestStepFinished
                     * @classdesc Represents a TestStepResult.
                     * @implements ITestStepResult
                     * @constructor
                     * @param {io.cucumber.messages.TestStepFinished.ITestStepResult=} [properties] Properties to set
                     */
                    function TestStepResult(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TestStepResult status.
                     * @member {io.cucumber.messages.TestStepFinished.TestStepResult.Status} status
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @instance
                     */
                    TestStepResult.prototype.status = 0;

                    /**
                     * TestStepResult message.
                     * @member {string} message
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @instance
                     */
                    TestStepResult.prototype.message = "";

                    /**
                     * TestStepResult duration.
                     * @member {io.cucumber.messages.IDuration|null|undefined} duration
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @instance
                     */
                    TestStepResult.prototype.duration = null;

                    /**
                     * TestStepResult willBeRetried.
                     * @member {boolean} willBeRetried
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @instance
                     */
                    TestStepResult.prototype.willBeRetried = false;

                    /**
                     * Creates a new TestStepResult instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @static
                     * @param {io.cucumber.messages.TestStepFinished.ITestStepResult=} [properties] Properties to set
                     * @returns {io.cucumber.messages.TestStepFinished.TestStepResult} TestStepResult instance
                     */
                    TestStepResult.create = function create(properties) {
                        return new TestStepResult(properties);
                    };

                    /**
                     * Encodes the specified TestStepResult message. Does not implicitly {@link io.cucumber.messages.TestStepFinished.TestStepResult.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @static
                     * @param {io.cucumber.messages.TestStepFinished.ITestStepResult} message TestStepResult message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TestStepResult.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                        if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                            $root.io.cucumber.messages.Duration.encode(message.duration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.willBeRetried != null && Object.hasOwnProperty.call(message, "willBeRetried"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.willBeRetried);
                        return writer;
                    };

                    /**
                     * Encodes the specified TestStepResult message, length delimited. Does not implicitly {@link io.cucumber.messages.TestStepFinished.TestStepResult.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @static
                     * @param {io.cucumber.messages.TestStepFinished.ITestStepResult} message TestStepResult message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TestStepResult.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TestStepResult message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.TestStepFinished.TestStepResult} TestStepResult
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TestStepResult.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestStepFinished.TestStepResult();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.status = reader.int32();
                                break;
                            case 2:
                                message.message = reader.string();
                                break;
                            case 3:
                                message.duration = $root.io.cucumber.messages.Duration.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.willBeRetried = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TestStepResult message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.TestStepFinished.TestStepResult} TestStepResult
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TestStepResult.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TestStepResult message.
                     * @function verify
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TestStepResult.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.message != null && message.hasOwnProperty("message"))
                            if (!$util.isString(message.message))
                                return "message: string expected";
                        if (message.duration != null && message.hasOwnProperty("duration")) {
                            var error = $root.io.cucumber.messages.Duration.verify(message.duration);
                            if (error)
                                return "duration." + error;
                        }
                        if (message.willBeRetried != null && message.hasOwnProperty("willBeRetried"))
                            if (typeof message.willBeRetried !== "boolean")
                                return "willBeRetried: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a TestStepResult message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.TestStepFinished.TestStepResult} TestStepResult
                     */
                    TestStepResult.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.TestStepFinished.TestStepResult)
                            return object;
                        var message = new $root.io.cucumber.messages.TestStepFinished.TestStepResult();
                        switch (object.status) {
                        case "UNKNOWN":
                        case 0:
                            message.status = 0;
                            break;
                        case "PASSED":
                        case 1:
                            message.status = 1;
                            break;
                        case "SKIPPED":
                        case 2:
                            message.status = 2;
                            break;
                        case "PENDING":
                        case 3:
                            message.status = 3;
                            break;
                        case "UNDEFINED":
                        case 4:
                            message.status = 4;
                            break;
                        case "AMBIGUOUS":
                        case 5:
                            message.status = 5;
                            break;
                        case "FAILED":
                        case 6:
                            message.status = 6;
                            break;
                        }
                        if (object.message != null)
                            message.message = String(object.message);
                        if (object.duration != null) {
                            if (typeof object.duration !== "object")
                                throw TypeError(".io.cucumber.messages.TestStepFinished.TestStepResult.duration: object expected");
                            message.duration = $root.io.cucumber.messages.Duration.fromObject(object.duration);
                        }
                        if (object.willBeRetried != null)
                            message.willBeRetried = Boolean(object.willBeRetried);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TestStepResult message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @static
                     * @param {io.cucumber.messages.TestStepFinished.TestStepResult} message TestStepResult
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TestStepResult.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.status = options.enums === String ? "UNKNOWN" : 0;
                            object.message = "";
                            object.duration = null;
                            object.willBeRetried = false;
                        }
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.io.cucumber.messages.TestStepFinished.TestStepResult.Status[message.status] : message.status;
                        if (message.message != null && message.hasOwnProperty("message"))
                            object.message = message.message;
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            object.duration = $root.io.cucumber.messages.Duration.toObject(message.duration, options);
                        if (message.willBeRetried != null && message.hasOwnProperty("willBeRetried"))
                            object.willBeRetried = message.willBeRetried;
                        return object;
                    };

                    /**
                     * Converts this TestStepResult to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.TestStepFinished.TestStepResult
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TestStepResult.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Status of a `TestStep`.
                     * 
                     * The ordinal values of statuses are significant. The status of a TestCase
                     * is computed by picking the status with the highest value for all of its steps.
                     * 
                     * For example, if a TestCase has steps with statuses passed, undefined and skipped,
                     * then the pickle's status is undefined.
                     * @name io.cucumber.messages.TestStepFinished.TestStepResult.Status
                     * @enum {number}
                     * @property {number} UNKNOWN=0 UNKNOWN value
                     * @property {number} PASSED=1 PASSED value
                     * @property {number} SKIPPED=2 SKIPPED value
                     * @property {number} PENDING=3 PENDING value
                     * @property {number} UNDEFINED=4 UNDEFINED value
                     * @property {number} AMBIGUOUS=5 AMBIGUOUS value
                     * @property {number} FAILED=6 FAILED value
                     */
                    TestStepResult.Status = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN"] = 0;
                        values[valuesById[1] = "PASSED"] = 1;
                        values[valuesById[2] = "SKIPPED"] = 2;
                        values[valuesById[3] = "PENDING"] = 3;
                        values[valuesById[4] = "UNDEFINED"] = 4;
                        values[valuesById[5] = "AMBIGUOUS"] = 5;
                        values[valuesById[6] = "FAILED"] = 6;
                        return values;
                    })();

                    return TestStepResult;
                })();

                return TestStepFinished;
            })();

            messages.TestRunFinished = (function() {

                /**
                 * Properties of a TestRunFinished.
                 * @memberof io.cucumber.messages
                 * @interface ITestRunFinished
                 * @property {boolean|null} [success] TestRunFinished success
                 * @property {io.cucumber.messages.ITimestamp|null} [timestamp] TestRunFinished timestamp
                 * @property {string|null} [message] TestRunFinished message
                 */

                /**
                 * Constructs a new TestRunFinished.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a TestRunFinished.
                 * @implements ITestRunFinished
                 * @constructor
                 * @param {io.cucumber.messages.ITestRunFinished=} [properties] Properties to set
                 */
                function TestRunFinished(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TestRunFinished success.
                 * @member {boolean} success
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @instance
                 */
                TestRunFinished.prototype.success = false;

                /**
                 * TestRunFinished timestamp.
                 * @member {io.cucumber.messages.ITimestamp|null|undefined} timestamp
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @instance
                 */
                TestRunFinished.prototype.timestamp = null;

                /**
                 * TestRunFinished message.
                 * @member {string} message
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @instance
                 */
                TestRunFinished.prototype.message = "";

                /**
                 * Creates a new TestRunFinished instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {io.cucumber.messages.ITestRunFinished=} [properties] Properties to set
                 * @returns {io.cucumber.messages.TestRunFinished} TestRunFinished instance
                 */
                TestRunFinished.create = function create(properties) {
                    return new TestRunFinished(properties);
                };

                /**
                 * Encodes the specified TestRunFinished message. Does not implicitly {@link io.cucumber.messages.TestRunFinished.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {io.cucumber.messages.ITestRunFinished} message TestRunFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestRunFinished.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.success);
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.io.cucumber.messages.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
                    return writer;
                };

                /**
                 * Encodes the specified TestRunFinished message, length delimited. Does not implicitly {@link io.cucumber.messages.TestRunFinished.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {io.cucumber.messages.ITestRunFinished} message TestRunFinished message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TestRunFinished.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TestRunFinished message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.TestRunFinished} TestRunFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestRunFinished.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.TestRunFinished();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.success = reader.bool();
                            break;
                        case 2:
                            message.timestamp = $root.io.cucumber.messages.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TestRunFinished message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.TestRunFinished} TestRunFinished
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TestRunFinished.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TestRunFinished message.
                 * @function verify
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TestRunFinished.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.success != null && message.hasOwnProperty("success"))
                        if (typeof message.success !== "boolean")
                            return "success: boolean expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.io.cucumber.messages.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };

                /**
                 * Creates a TestRunFinished message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.TestRunFinished} TestRunFinished
                 */
                TestRunFinished.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.TestRunFinished)
                        return object;
                    var message = new $root.io.cucumber.messages.TestRunFinished();
                    if (object.success != null)
                        message.success = Boolean(object.success);
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".io.cucumber.messages.TestRunFinished.timestamp: object expected");
                        message.timestamp = $root.io.cucumber.messages.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates a plain object from a TestRunFinished message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @static
                 * @param {io.cucumber.messages.TestRunFinished} message TestRunFinished
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TestRunFinished.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.success = false;
                        object.timestamp = null;
                        object.message = "";
                    }
                    if (message.success != null && message.hasOwnProperty("success"))
                        object.success = message.success;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.io.cucumber.messages.Timestamp.toObject(message.timestamp, options);
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };

                /**
                 * Converts this TestRunFinished to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.TestRunFinished
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TestRunFinished.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TestRunFinished;
            })();

            messages.Hook = (function() {

                /**
                 * Properties of a Hook.
                 * @memberof io.cucumber.messages
                 * @interface IHook
                 * @property {string|null} [id] Hook id
                 * @property {string|null} [tagExpression] Hook tagExpression
                 * @property {io.cucumber.messages.ISourceReference|null} [sourceReference] Hook sourceReference
                 */

                /**
                 * Constructs a new Hook.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a Hook.
                 * @implements IHook
                 * @constructor
                 * @param {io.cucumber.messages.IHook=} [properties] Properties to set
                 */
                function Hook(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Hook id.
                 * @member {string} id
                 * @memberof io.cucumber.messages.Hook
                 * @instance
                 */
                Hook.prototype.id = "";

                /**
                 * Hook tagExpression.
                 * @member {string} tagExpression
                 * @memberof io.cucumber.messages.Hook
                 * @instance
                 */
                Hook.prototype.tagExpression = "";

                /**
                 * Hook sourceReference.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} sourceReference
                 * @memberof io.cucumber.messages.Hook
                 * @instance
                 */
                Hook.prototype.sourceReference = null;

                /**
                 * Creates a new Hook instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {io.cucumber.messages.IHook=} [properties] Properties to set
                 * @returns {io.cucumber.messages.Hook} Hook instance
                 */
                Hook.create = function create(properties) {
                    return new Hook(properties);
                };

                /**
                 * Encodes the specified Hook message. Does not implicitly {@link io.cucumber.messages.Hook.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {io.cucumber.messages.IHook} message Hook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Hook.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.tagExpression != null && Object.hasOwnProperty.call(message, "tagExpression"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.tagExpression);
                    if (message.sourceReference != null && Object.hasOwnProperty.call(message, "sourceReference"))
                        $root.io.cucumber.messages.SourceReference.encode(message.sourceReference, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Hook message, length delimited. Does not implicitly {@link io.cucumber.messages.Hook.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {io.cucumber.messages.IHook} message Hook message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Hook.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Hook message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.Hook} Hook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Hook.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.Hook();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.tagExpression = reader.string();
                            break;
                        case 3:
                            message.sourceReference = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Hook message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.Hook} Hook
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Hook.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Hook message.
                 * @function verify
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Hook.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.tagExpression != null && message.hasOwnProperty("tagExpression"))
                        if (!$util.isString(message.tagExpression))
                            return "tagExpression: string expected";
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.sourceReference);
                        if (error)
                            return "sourceReference." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Hook message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.Hook} Hook
                 */
                Hook.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.Hook)
                        return object;
                    var message = new $root.io.cucumber.messages.Hook();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.tagExpression != null)
                        message.tagExpression = String(object.tagExpression);
                    if (object.sourceReference != null) {
                        if (typeof object.sourceReference !== "object")
                            throw TypeError(".io.cucumber.messages.Hook.sourceReference: object expected");
                        message.sourceReference = $root.io.cucumber.messages.SourceReference.fromObject(object.sourceReference);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Hook message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.Hook
                 * @static
                 * @param {io.cucumber.messages.Hook} message Hook
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Hook.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.tagExpression = "";
                        object.sourceReference = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.tagExpression != null && message.hasOwnProperty("tagExpression"))
                        object.tagExpression = message.tagExpression;
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference"))
                        object.sourceReference = $root.io.cucumber.messages.SourceReference.toObject(message.sourceReference, options);
                    return object;
                };

                /**
                 * Converts this Hook to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.Hook
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Hook.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Hook;
            })();

            messages.StepDefinition = (function() {

                /**
                 * Properties of a StepDefinition.
                 * @memberof io.cucumber.messages
                 * @interface IStepDefinition
                 * @property {string|null} [id] StepDefinition id
                 * @property {io.cucumber.messages.StepDefinition.IStepDefinitionPattern|null} [pattern] StepDefinition pattern
                 * @property {io.cucumber.messages.ISourceReference|null} [sourceReference] StepDefinition sourceReference
                 */

                /**
                 * Constructs a new StepDefinition.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a StepDefinition.
                 * @implements IStepDefinition
                 * @constructor
                 * @param {io.cucumber.messages.IStepDefinition=} [properties] Properties to set
                 */
                function StepDefinition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StepDefinition id.
                 * @member {string} id
                 * @memberof io.cucumber.messages.StepDefinition
                 * @instance
                 */
                StepDefinition.prototype.id = "";

                /**
                 * StepDefinition pattern.
                 * @member {io.cucumber.messages.StepDefinition.IStepDefinitionPattern|null|undefined} pattern
                 * @memberof io.cucumber.messages.StepDefinition
                 * @instance
                 */
                StepDefinition.prototype.pattern = null;

                /**
                 * StepDefinition sourceReference.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} sourceReference
                 * @memberof io.cucumber.messages.StepDefinition
                 * @instance
                 */
                StepDefinition.prototype.sourceReference = null;

                /**
                 * Creates a new StepDefinition instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {io.cucumber.messages.IStepDefinition=} [properties] Properties to set
                 * @returns {io.cucumber.messages.StepDefinition} StepDefinition instance
                 */
                StepDefinition.create = function create(properties) {
                    return new StepDefinition(properties);
                };

                /**
                 * Encodes the specified StepDefinition message. Does not implicitly {@link io.cucumber.messages.StepDefinition.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {io.cucumber.messages.IStepDefinition} message StepDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepDefinition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                    if (message.pattern != null && Object.hasOwnProperty.call(message, "pattern"))
                        $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern.encode(message.pattern, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.sourceReference != null && Object.hasOwnProperty.call(message, "sourceReference"))
                        $root.io.cucumber.messages.SourceReference.encode(message.sourceReference, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StepDefinition message, length delimited. Does not implicitly {@link io.cucumber.messages.StepDefinition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {io.cucumber.messages.IStepDefinition} message StepDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StepDefinition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StepDefinition message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.StepDefinition} StepDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepDefinition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.StepDefinition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.string();
                            break;
                        case 2:
                            message.pattern = $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.sourceReference = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StepDefinition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.StepDefinition} StepDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StepDefinition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StepDefinition message.
                 * @function verify
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StepDefinition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.pattern != null && message.hasOwnProperty("pattern")) {
                        var error = $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern.verify(message.pattern);
                        if (error)
                            return "pattern." + error;
                    }
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.sourceReference);
                        if (error)
                            return "sourceReference." + error;
                    }
                    return null;
                };

                /**
                 * Creates a StepDefinition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.StepDefinition} StepDefinition
                 */
                StepDefinition.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.StepDefinition)
                        return object;
                    var message = new $root.io.cucumber.messages.StepDefinition();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.pattern != null) {
                        if (typeof object.pattern !== "object")
                            throw TypeError(".io.cucumber.messages.StepDefinition.pattern: object expected");
                        message.pattern = $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern.fromObject(object.pattern);
                    }
                    if (object.sourceReference != null) {
                        if (typeof object.sourceReference !== "object")
                            throw TypeError(".io.cucumber.messages.StepDefinition.sourceReference: object expected");
                        message.sourceReference = $root.io.cucumber.messages.SourceReference.fromObject(object.sourceReference);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StepDefinition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.StepDefinition
                 * @static
                 * @param {io.cucumber.messages.StepDefinition} message StepDefinition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StepDefinition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.pattern = null;
                        object.sourceReference = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        object.pattern = $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern.toObject(message.pattern, options);
                    if (message.sourceReference != null && message.hasOwnProperty("sourceReference"))
                        object.sourceReference = $root.io.cucumber.messages.SourceReference.toObject(message.sourceReference, options);
                    return object;
                };

                /**
                 * Converts this StepDefinition to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.StepDefinition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StepDefinition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                StepDefinition.StepDefinitionPattern = (function() {

                    /**
                     * Properties of a StepDefinitionPattern.
                     * @memberof io.cucumber.messages.StepDefinition
                     * @interface IStepDefinitionPattern
                     * @property {string|null} [source] StepDefinitionPattern source
                     * @property {io.cucumber.messages.StepDefinition.StepDefinitionPattern.StepDefinitionPatternType|null} [type] StepDefinitionPattern type
                     */

                    /**
                     * Constructs a new StepDefinitionPattern.
                     * @memberof io.cucumber.messages.StepDefinition
                     * @classdesc Represents a StepDefinitionPattern.
                     * @implements IStepDefinitionPattern
                     * @constructor
                     * @param {io.cucumber.messages.StepDefinition.IStepDefinitionPattern=} [properties] Properties to set
                     */
                    function StepDefinitionPattern(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * StepDefinitionPattern source.
                     * @member {string} source
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @instance
                     */
                    StepDefinitionPattern.prototype.source = "";

                    /**
                     * StepDefinitionPattern type.
                     * @member {io.cucumber.messages.StepDefinition.StepDefinitionPattern.StepDefinitionPatternType} type
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @instance
                     */
                    StepDefinitionPattern.prototype.type = 0;

                    /**
                     * Creates a new StepDefinitionPattern instance using the specified properties.
                     * @function create
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @static
                     * @param {io.cucumber.messages.StepDefinition.IStepDefinitionPattern=} [properties] Properties to set
                     * @returns {io.cucumber.messages.StepDefinition.StepDefinitionPattern} StepDefinitionPattern instance
                     */
                    StepDefinitionPattern.create = function create(properties) {
                        return new StepDefinitionPattern(properties);
                    };

                    /**
                     * Encodes the specified StepDefinitionPattern message. Does not implicitly {@link io.cucumber.messages.StepDefinition.StepDefinitionPattern.verify|verify} messages.
                     * @function encode
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @static
                     * @param {io.cucumber.messages.StepDefinition.IStepDefinitionPattern} message StepDefinitionPattern message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StepDefinitionPattern.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.source);
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified StepDefinitionPattern message, length delimited. Does not implicitly {@link io.cucumber.messages.StepDefinition.StepDefinitionPattern.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @static
                     * @param {io.cucumber.messages.StepDefinition.IStepDefinitionPattern} message StepDefinitionPattern message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StepDefinitionPattern.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a StepDefinitionPattern message from the specified reader or buffer.
                     * @function decode
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {io.cucumber.messages.StepDefinition.StepDefinitionPattern} StepDefinitionPattern
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StepDefinitionPattern.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.source = reader.string();
                                break;
                            case 2:
                                message.type = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a StepDefinitionPattern message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {io.cucumber.messages.StepDefinition.StepDefinitionPattern} StepDefinitionPattern
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StepDefinitionPattern.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a StepDefinitionPattern message.
                     * @function verify
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StepDefinitionPattern.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.source != null && message.hasOwnProperty("source"))
                            if (!$util.isString(message.source))
                                return "source: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a StepDefinitionPattern message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {io.cucumber.messages.StepDefinition.StepDefinitionPattern} StepDefinitionPattern
                     */
                    StepDefinitionPattern.fromObject = function fromObject(object) {
                        if (object instanceof $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern)
                            return object;
                        var message = new $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern();
                        if (object.source != null)
                            message.source = String(object.source);
                        switch (object.type) {
                        case "CUCUMBER_EXPRESSION":
                        case 0:
                            message.type = 0;
                            break;
                        case "REGULAR_EXPRESSION":
                        case 1:
                            message.type = 1;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a StepDefinitionPattern message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @static
                     * @param {io.cucumber.messages.StepDefinition.StepDefinitionPattern} message StepDefinitionPattern
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StepDefinitionPattern.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.source = "";
                            object.type = options.enums === String ? "CUCUMBER_EXPRESSION" : 0;
                        }
                        if (message.source != null && message.hasOwnProperty("source"))
                            object.source = message.source;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.io.cucumber.messages.StepDefinition.StepDefinitionPattern.StepDefinitionPatternType[message.type] : message.type;
                        return object;
                    };

                    /**
                     * Converts this StepDefinitionPattern to JSON.
                     * @function toJSON
                     * @memberof io.cucumber.messages.StepDefinition.StepDefinitionPattern
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StepDefinitionPattern.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * StepDefinitionPatternType enum.
                     * @name io.cucumber.messages.StepDefinition.StepDefinitionPattern.StepDefinitionPatternType
                     * @enum {number}
                     * @property {number} CUCUMBER_EXPRESSION=0 CUCUMBER_EXPRESSION value
                     * @property {number} REGULAR_EXPRESSION=1 REGULAR_EXPRESSION value
                     */
                    StepDefinitionPattern.StepDefinitionPatternType = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "CUCUMBER_EXPRESSION"] = 0;
                        values[valuesById[1] = "REGULAR_EXPRESSION"] = 1;
                        return values;
                    })();

                    return StepDefinitionPattern;
                })();

                return StepDefinition;
            })();

            messages.ParameterType = (function() {

                /**
                 * Properties of a ParameterType.
                 * @memberof io.cucumber.messages
                 * @interface IParameterType
                 * @property {string|null} [name] ParameterType name
                 * @property {Array.<string>|null} [regularExpressions] ParameterType regularExpressions
                 * @property {boolean|null} [preferForRegularExpressionMatch] ParameterType preferForRegularExpressionMatch
                 * @property {boolean|null} [useForSnippets] ParameterType useForSnippets
                 * @property {string|null} [id] ParameterType id
                 */

                /**
                 * Constructs a new ParameterType.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a ParameterType.
                 * @implements IParameterType
                 * @constructor
                 * @param {io.cucumber.messages.IParameterType=} [properties] Properties to set
                 */
                function ParameterType(properties) {
                    this.regularExpressions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ParameterType name.
                 * @member {string} name
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.name = "";

                /**
                 * ParameterType regularExpressions.
                 * @member {Array.<string>} regularExpressions
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.regularExpressions = $util.emptyArray;

                /**
                 * ParameterType preferForRegularExpressionMatch.
                 * @member {boolean} preferForRegularExpressionMatch
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.preferForRegularExpressionMatch = false;

                /**
                 * ParameterType useForSnippets.
                 * @member {boolean} useForSnippets
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.useForSnippets = false;

                /**
                 * ParameterType id.
                 * @member {string} id
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 */
                ParameterType.prototype.id = "";

                /**
                 * Creates a new ParameterType instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {io.cucumber.messages.IParameterType=} [properties] Properties to set
                 * @returns {io.cucumber.messages.ParameterType} ParameterType instance
                 */
                ParameterType.create = function create(properties) {
                    return new ParameterType(properties);
                };

                /**
                 * Encodes the specified ParameterType message. Does not implicitly {@link io.cucumber.messages.ParameterType.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {io.cucumber.messages.IParameterType} message ParameterType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParameterType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.regularExpressions != null && message.regularExpressions.length)
                        for (var i = 0; i < message.regularExpressions.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.regularExpressions[i]);
                    if (message.preferForRegularExpressionMatch != null && Object.hasOwnProperty.call(message, "preferForRegularExpressionMatch"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.preferForRegularExpressionMatch);
                    if (message.useForSnippets != null && Object.hasOwnProperty.call(message, "useForSnippets"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.useForSnippets);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.id);
                    return writer;
                };

                /**
                 * Encodes the specified ParameterType message, length delimited. Does not implicitly {@link io.cucumber.messages.ParameterType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {io.cucumber.messages.IParameterType} message ParameterType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParameterType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ParameterType message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.ParameterType} ParameterType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParameterType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.ParameterType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.regularExpressions && message.regularExpressions.length))
                                message.regularExpressions = [];
                            message.regularExpressions.push(reader.string());
                            break;
                        case 3:
                            message.preferForRegularExpressionMatch = reader.bool();
                            break;
                        case 4:
                            message.useForSnippets = reader.bool();
                            break;
                        case 5:
                            message.id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ParameterType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.ParameterType} ParameterType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParameterType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ParameterType message.
                 * @function verify
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ParameterType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.regularExpressions != null && message.hasOwnProperty("regularExpressions")) {
                        if (!Array.isArray(message.regularExpressions))
                            return "regularExpressions: array expected";
                        for (var i = 0; i < message.regularExpressions.length; ++i)
                            if (!$util.isString(message.regularExpressions[i]))
                                return "regularExpressions: string[] expected";
                    }
                    if (message.preferForRegularExpressionMatch != null && message.hasOwnProperty("preferForRegularExpressionMatch"))
                        if (typeof message.preferForRegularExpressionMatch !== "boolean")
                            return "preferForRegularExpressionMatch: boolean expected";
                    if (message.useForSnippets != null && message.hasOwnProperty("useForSnippets"))
                        if (typeof message.useForSnippets !== "boolean")
                            return "useForSnippets: boolean expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    return null;
                };

                /**
                 * Creates a ParameterType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.ParameterType} ParameterType
                 */
                ParameterType.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.ParameterType)
                        return object;
                    var message = new $root.io.cucumber.messages.ParameterType();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.regularExpressions) {
                        if (!Array.isArray(object.regularExpressions))
                            throw TypeError(".io.cucumber.messages.ParameterType.regularExpressions: array expected");
                        message.regularExpressions = [];
                        for (var i = 0; i < object.regularExpressions.length; ++i)
                            message.regularExpressions[i] = String(object.regularExpressions[i]);
                    }
                    if (object.preferForRegularExpressionMatch != null)
                        message.preferForRegularExpressionMatch = Boolean(object.preferForRegularExpressionMatch);
                    if (object.useForSnippets != null)
                        message.useForSnippets = Boolean(object.useForSnippets);
                    if (object.id != null)
                        message.id = String(object.id);
                    return message;
                };

                /**
                 * Creates a plain object from a ParameterType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.ParameterType
                 * @static
                 * @param {io.cucumber.messages.ParameterType} message ParameterType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ParameterType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.regularExpressions = [];
                    if (options.defaults) {
                        object.name = "";
                        object.preferForRegularExpressionMatch = false;
                        object.useForSnippets = false;
                        object.id = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.regularExpressions && message.regularExpressions.length) {
                        object.regularExpressions = [];
                        for (var j = 0; j < message.regularExpressions.length; ++j)
                            object.regularExpressions[j] = message.regularExpressions[j];
                    }
                    if (message.preferForRegularExpressionMatch != null && message.hasOwnProperty("preferForRegularExpressionMatch"))
                        object.preferForRegularExpressionMatch = message.preferForRegularExpressionMatch;
                    if (message.useForSnippets != null && message.hasOwnProperty("useForSnippets"))
                        object.useForSnippets = message.useForSnippets;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    return object;
                };

                /**
                 * Converts this ParameterType to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.ParameterType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ParameterType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ParameterType;
            })();

            messages.UndefinedParameterType = (function() {

                /**
                 * Properties of an UndefinedParameterType.
                 * @memberof io.cucumber.messages
                 * @interface IUndefinedParameterType
                 * @property {string|null} [name] UndefinedParameterType name
                 * @property {string|null} [expression] UndefinedParameterType expression
                 */

                /**
                 * Constructs a new UndefinedParameterType.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents an UndefinedParameterType.
                 * @implements IUndefinedParameterType
                 * @constructor
                 * @param {io.cucumber.messages.IUndefinedParameterType=} [properties] Properties to set
                 */
                function UndefinedParameterType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UndefinedParameterType name.
                 * @member {string} name
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @instance
                 */
                UndefinedParameterType.prototype.name = "";

                /**
                 * UndefinedParameterType expression.
                 * @member {string} expression
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @instance
                 */
                UndefinedParameterType.prototype.expression = "";

                /**
                 * Creates a new UndefinedParameterType instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @static
                 * @param {io.cucumber.messages.IUndefinedParameterType=} [properties] Properties to set
                 * @returns {io.cucumber.messages.UndefinedParameterType} UndefinedParameterType instance
                 */
                UndefinedParameterType.create = function create(properties) {
                    return new UndefinedParameterType(properties);
                };

                /**
                 * Encodes the specified UndefinedParameterType message. Does not implicitly {@link io.cucumber.messages.UndefinedParameterType.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @static
                 * @param {io.cucumber.messages.IUndefinedParameterType} message UndefinedParameterType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UndefinedParameterType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.expression != null && Object.hasOwnProperty.call(message, "expression"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.expression);
                    return writer;
                };

                /**
                 * Encodes the specified UndefinedParameterType message, length delimited. Does not implicitly {@link io.cucumber.messages.UndefinedParameterType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @static
                 * @param {io.cucumber.messages.IUndefinedParameterType} message UndefinedParameterType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UndefinedParameterType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UndefinedParameterType message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.UndefinedParameterType} UndefinedParameterType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UndefinedParameterType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.UndefinedParameterType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.expression = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UndefinedParameterType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.UndefinedParameterType} UndefinedParameterType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UndefinedParameterType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UndefinedParameterType message.
                 * @function verify
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UndefinedParameterType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.expression != null && message.hasOwnProperty("expression"))
                        if (!$util.isString(message.expression))
                            return "expression: string expected";
                    return null;
                };

                /**
                 * Creates an UndefinedParameterType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.UndefinedParameterType} UndefinedParameterType
                 */
                UndefinedParameterType.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.UndefinedParameterType)
                        return object;
                    var message = new $root.io.cucumber.messages.UndefinedParameterType();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.expression != null)
                        message.expression = String(object.expression);
                    return message;
                };

                /**
                 * Creates a plain object from an UndefinedParameterType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @static
                 * @param {io.cucumber.messages.UndefinedParameterType} message UndefinedParameterType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UndefinedParameterType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.expression = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.expression != null && message.hasOwnProperty("expression"))
                        object.expression = message.expression;
                    return object;
                };

                /**
                 * Converts this UndefinedParameterType to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.UndefinedParameterType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UndefinedParameterType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UndefinedParameterType;
            })();

            messages.ParseError = (function() {

                /**
                 * Properties of a ParseError.
                 * @memberof io.cucumber.messages
                 * @interface IParseError
                 * @property {io.cucumber.messages.ISourceReference|null} [source] ParseError source
                 * @property {string|null} [message] ParseError message
                 */

                /**
                 * Constructs a new ParseError.
                 * @memberof io.cucumber.messages
                 * @classdesc Represents a ParseError.
                 * @implements IParseError
                 * @constructor
                 * @param {io.cucumber.messages.IParseError=} [properties] Properties to set
                 */
                function ParseError(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ParseError source.
                 * @member {io.cucumber.messages.ISourceReference|null|undefined} source
                 * @memberof io.cucumber.messages.ParseError
                 * @instance
                 */
                ParseError.prototype.source = null;

                /**
                 * ParseError message.
                 * @member {string} message
                 * @memberof io.cucumber.messages.ParseError
                 * @instance
                 */
                ParseError.prototype.message = "";

                /**
                 * Creates a new ParseError instance using the specified properties.
                 * @function create
                 * @memberof io.cucumber.messages.ParseError
                 * @static
                 * @param {io.cucumber.messages.IParseError=} [properties] Properties to set
                 * @returns {io.cucumber.messages.ParseError} ParseError instance
                 */
                ParseError.create = function create(properties) {
                    return new ParseError(properties);
                };

                /**
                 * Encodes the specified ParseError message. Does not implicitly {@link io.cucumber.messages.ParseError.verify|verify} messages.
                 * @function encode
                 * @memberof io.cucumber.messages.ParseError
                 * @static
                 * @param {io.cucumber.messages.IParseError} message ParseError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParseError.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                        $root.io.cucumber.messages.SourceReference.encode(message.source, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    return writer;
                };

                /**
                 * Encodes the specified ParseError message, length delimited. Does not implicitly {@link io.cucumber.messages.ParseError.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof io.cucumber.messages.ParseError
                 * @static
                 * @param {io.cucumber.messages.IParseError} message ParseError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ParseError.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ParseError message from the specified reader or buffer.
                 * @function decode
                 * @memberof io.cucumber.messages.ParseError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {io.cucumber.messages.ParseError} ParseError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParseError.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.io.cucumber.messages.ParseError();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.source = $root.io.cucumber.messages.SourceReference.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ParseError message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof io.cucumber.messages.ParseError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {io.cucumber.messages.ParseError} ParseError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ParseError.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ParseError message.
                 * @function verify
                 * @memberof io.cucumber.messages.ParseError
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ParseError.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.source != null && message.hasOwnProperty("source")) {
                        var error = $root.io.cucumber.messages.SourceReference.verify(message.source);
                        if (error)
                            return "source." + error;
                    }
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };

                /**
                 * Creates a ParseError message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof io.cucumber.messages.ParseError
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {io.cucumber.messages.ParseError} ParseError
                 */
                ParseError.fromObject = function fromObject(object) {
                    if (object instanceof $root.io.cucumber.messages.ParseError)
                        return object;
                    var message = new $root.io.cucumber.messages.ParseError();
                    if (object.source != null) {
                        if (typeof object.source !== "object")
                            throw TypeError(".io.cucumber.messages.ParseError.source: object expected");
                        message.source = $root.io.cucumber.messages.SourceReference.fromObject(object.source);
                    }
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates a plain object from a ParseError message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof io.cucumber.messages.ParseError
                 * @static
                 * @param {io.cucumber.messages.ParseError} message ParseError
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ParseError.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.source = null;
                        object.message = "";
                    }
                    if (message.source != null && message.hasOwnProperty("source"))
                        object.source = $root.io.cucumber.messages.SourceReference.toObject(message.source, options);
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };

                /**
                 * Converts this ParseError to JSON.
                 * @function toJSON
                 * @memberof io.cucumber.messages.ParseError
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ParseError.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ParseError;
            })();

            return messages;
        })();

        return cucumber;
    })();

    return io;
})();

module.exports = $root;
